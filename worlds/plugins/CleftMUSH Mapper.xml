<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Friday, July 26, 2019, 7:21 AM -->
<!-- MuClient version 4.51 -->
<!DOCTYPE muclient [
  <!ENTITY show_vnums "true" > 
  <!ENTITY show_timing "false" > 
  <!ENTITY show_completed "false" > 
  <!ENTITY show_database_mods "true" > 
  <!ENTITY show_other_areas "true" > 
  <!ENTITY show_area_exits "true" > 
  <!ENTITY show_up_down "false" > 
  <!ENTITY speedwalk_prefix "" > 
]>
<!-- Plugin "CleftMapper" generated by Plugin Wizard -->

<muclient>
<plugin
   name="CleftMUSH_Mapper"
   author="Asmodeus"
   id="dd07d6dbe73fe0bd02ddb62c"
   language="Lua"
   purpose="Shows the map for Cleft of Dimensions"
   save_state="y"
   date_written="2019-07-26 07:21:01"
   requires="4.51"
   version="6.02"
   >

</plugin>

<aliases>

  <!--  zooming aliases -->

 <alias
   match="mapper zoom out"
   enabled="y"
   sequence="100"
   omit_from_command_history="y"
   omit_from_output="y"
   script="mapper.zoom_out"
  >
  </alias>

<alias
   match="mapper zoom in"
   enabled="y"
   sequence="100"
   omit_from_command_history="y"
   omit_from_output="y"
   script="mapper.zoom_in"
  >
  </alias>
<alias
   match="^mapper addnote( .*)?$"
   regexp="y"
   enabled="y"
   sequence="100"
   send_to="12"
>
<send>
   room_edit_note(nil,nil,Trim("%1"))
</send>
</alias>
   <alias
      match="^mapper shownotes( (on|off))?$"
      regexp="y"
      enabled="y"
      sequence="100"
      script="shownote_toggle"
   ></alias>
<alias
   match="^mapper next( .*)?$"
   enabled="y"
   regexp="y"
   sequence="100"
   send_to="12"
>
<send>
mapper.gotoNextResult(Trim("%1"))
</send>
</alias>

 <alias
   match="mapper resume"
   enabled="y"
   sequence="100"
   script="map_resume"
  >
 
  </alias>  
 <alias
   match="go"
   enabled="y"
   sequence="100"
   script="map_resume"
  >
 
  </alias>  
 <alias
   match="mapper stop"
   enabled="y"
   sequence="100"
   script="mapper.cancel_speedwalk"
  >
  </alias>
 <alias
   match="stop"
   enabled="y"
   sequence="100"
   script="mapper.cancel_speedwalk"
  >
  </alias>
  <alias
   match="^mapper print uid$"
   regexp="y"
   enabled="y"
   sequence="100"
   send_to="14"
  >
<send>util.print("{WRoom UID: {G" .. current_room)</send>
  </alias>
  <alias
   match="^mapper print$"
   regexp="y"
   enabled="y"
   sequence="100"
   send_to="14"
  >
<send>
util.print("{R--------------------------------------------------")
   AnsiNote(ColoursToANSI(" {WRoom UID: {Y"..current_room.."{R"))
   AnsiNote(ColoursToANSI(" {WName: {Y"..name.."{R"))
   AnsiNote(ColoursToANSI(" {WTerrain: {Y"..terrain.."{R"))
   AnsiNote(ColoursToANSI(" {WExits: {Y"..printexits.."{R"))
   AnsiNote(ColoursToANSI(" {WCurrent Area: {Y"..current_area.."{R"))
   local info
   if (rooms[uid] ~= nil and rooms[uid].info ~= nil and rooms[uid].info ~= "") then
      info = rooms[uid].info
   else
      info = " No flags"
   end
   AnsiNote(ColoursToANSI(" {WRoom Flags:{Y"..info.."{R"))
util.print("{R--------------------------------------------------")
</send>
  </alias>
  <!-- MAPPER CEXIT STUFF -->
   <alias
      match="^mapper cexit (.+)$"
      enabled="y"
      sequence="100"
      script="custom_exit"
      regexp="y"
   ></alias>
   <alias
      match="^mapper cexit_wait (.+)$"
      enabled="y"
      sequence="100"
      script="change_cexit_delay"
      regexp="y"
   ></alias>
   <alias
      match="mapper cexits *"
      enabled="y"
      sequence="100"
      script="custom_exit_list"
      regexp="n"
   ></alias>

   <alias
      match="mapper cexits"
      enabled="y"
      sequence="100"
      script="custom_exit_list"
      regexp="n"
   ></alias>
   <alias
      match="^mapper delete cexits$"
      enabled="y"
      sequence="100"
      script="map_cexits_delete"
      regexp="y"
   ></alias>

 <!--  show/hide mapper -->

  <alias
   match="mapper hide"
   enabled="y"
   sequence="100"
   script="mapper.hide"
  >
  </alias>

   <alias
   match="mapper show"
   enabled="y"
   sequence="100"
   script="mapper.show"
  >
  </alias>

<alias
   match="^mapper updown$"
   enabled="y"
   regexp="y"
   send_to="12"
>
<send>
   mapper.show_up_down = not mapper.show_up_down
   mapper.draw (current_room)
</send>
</alias>

<alias
   match="^mapper underlines?$"
   enabled="y"
   regexp="y"
   send_to="12"
>
<send>
   NoUnderline_hyperlinks = not NoUnderline_hyperlinks
   Note("Mapper hyperlinks will " ..(NoUnderline_hyperlinks and "no longer" or "now").." be underlined.")
   SetVariable("NoUnderline_hyperlinks", NoUnderline_hyperlinks and "1" or "0")
</send>
</alias>
<alias
   match="^mapper config roomcolor$"
   enabled="y"
   regexp="y"
   send_to="14"
><send>config_our_room_colour()</send></alias>
<alias
   match="^mapper config notecolor$"
   enabled="y"
   regexp="y"
   send_to="14"
><send>config_note_colour()</send></alias>
 <alias
   match="mapper goto *"
   enabled="y"
   sequence="100"
   script="map_goto"
  >
  </alias>
<alias
   match="mapper find *"
   ignore_case="y"
   enabled="y"
   sequence="100"
   script="map_find"
   regexp="n"
></alias>
<alias
   match="note find *"
   ignore_case="y"
   enabled="y"
   sequence="100"
   script="note_find"
   regexp="n"
></alias>
<alias
   match="desc find *"
   ignore_case="y"
   enabled="y"
   sequence="100"
   script="desc_find"
   regexp="n"
></alias>
<alias
   match="find *"
   ignore_case="y"
   enabled="y"
   sequence="100"
   script="map_find"
   regexp="n"
></alias>
<alias
   match="mapper findpath * *"
   enabled="y"
   sequence="100"
   omit_from_output="y"
   script="findpathfast"
></alias>

  <alias
   match="mapper where *"
   enabled="y"
   sequence="100"
   script="map_where"
  >
  </alias>
  <alias
   match="mapper backup"
   enabled="y"
   sequence="100"
   script="backup_db"
  >
  </alias>
  <alias
   match="^mapper delete room (\d\w+)$"
   enabled="y"
   regexp="y"
   script="delete_room_alias"
>
</alias>
<alias
   match="^mapper delete area (.+)$"
   enabled="y"
   regexp="y"
   script="delete_area_alias"
>
</alias>


<alias
  match="^mapper flags? (.*)$"
  enabled="y" 
  regexp="y" 
  sequence="100"
  script="updateRoomInfo">
</alias>
<alias
  match="^mapper uid$"
  enabled="y" 
  regexp="y" 
  sequence="100"
  script="updateRoomUid">
</alias>

<alias
  match="^mapper draw room$"
  enabled="y" 
  regexp="y" 
  sequence="100"
  send_to="14">
<send>mapper.draw (uid)</send>
</alias>

<alias
  match="^mapper delete room$"
  enabled="y" 
  regexp="y" 
  sequence="100"
  send_to="14">
<send>delete_room_click()</send>
</alias>

  <!-- MAPPER HELP STUFF -->
<alias
  match="^mapper help$"
  enabled="y" 
  regexp="y" 
  sequence="100"
  send_to="14">
<send>mapperhelp()</send>
</alias>
<alias
  match="^mapper help config$"
  enabled="y" 
  regexp="y" 
  sequence="100"
  send_to="14">
<send>mapperhelpconfig()</send>
</alias>
<alias
  match="^mapper help exits$"
  enabled="y" 
  regexp="y" 
  sequence="100"
  send_to="14">
<send>mapperhelpexits()</send>
</alias>
<alias
  match="^mapper help moving$"
  enabled="y" 
  regexp="y" 
  sequence="100"
  send_to="14">
<send>mapperhelpmoving()</send>
</alias>
<alias
  match="^mapper help utils$"
  enabled="y" 
  regexp="y" 
  sequence="100"
  send_to="14">
<send>mapperhelputils()</send>
</alias>
<alias
  match="^mapper help flags"
  enabled="y"
  regexp="y"
  sequence="100"
  send_to="14">
<send>mapperhelpflags()</send>
</alias>

 <alias
    enabled="n"
    group="look"
    name="Lookthing"
    keep_evaluating="y"
    match="^l (\w|\d).*$"
    omit_from_output="n"
    regexp="y"
    send_to="12"
    sequence="5"
    ><send>
EnableTrigger ("get_room_name", false)
EnableTrigger ("get_description_line", false)
EnableTrigger ("Exits_Line", false)
Execute("look %1")
DoAfterSpecial (0.1, 'EnableTrigger ("get_room_name", true)', sendto.script)
DoAfterSpecial (0.1, 'EnableTrigger ("Exits_Line", true)', sendto.script)
</send>
  </alias>

   <alias
      match="^mapper show tile( (on|off))?$"
      regexp="y"
      enabled="y"
      sequence="100"
      script="tile_show"
   ></alias>

<alias
match="UpdateTownSpecial"
enabled="n"
sequence="100"
>
<send>
where shops | prefix {Where Shop}
where banks | prefix {Where Bank}
where teachers | prefix {Where Teacher}
where forges | prefix {Where Forge}
</send>
</alias>
<alias
match="mapper show area"
enabled="y"
sequence="100"
send_to="14"
>
<send>
SetTriggerOption ("area_name", "enabled", 1)
SetTriggerOption ("area_name2", "enabled", 1)
SetVariable("show_areas", "Yes")
show_areas = "Yes"
util.print("{YArea names will now be {Rshown{Y on the map.")
mapper.draw(current_room)
--print("Show Areas: ", show_areas)
Execute("look")
if GetTriggerOption ("area_name", "enabled") == 0 and area ~= "" then
area=nil
end
SaveState()

--show_area()
</send>
</alias>
<alias
match="mapper hide area"
enabled="y"
sequence="100"
send_to="14"
>
<send>
SetTriggerOption ("area_name", "enabled", 0)
SetVariable("show_areas", "No")
show_areas = "No"
util.print("{YArea names will now be {Rhidden{Y from the map.")
SaveState()
--print("Show Areas: ", show_areas)
Execute("look")
if GetTriggerOption ("area_name", "enabled") == 0 and area ~= "" then
area=nil
end
--show_area()
</send>
</alias>
<alias
match="mapper show explored"
enabled="y"
sequence="100"
send_to="14"
>
<send>
cnt = GetVariable("cnt")
AnsiNote(ColoursToANSI("{YYou have explored {R" .. cnt .. " {Yrooms in the game."))
--print("Room Count: ", cnt)
</send>
</alias>

</aliases>


<!--  Triggers  -->

<triggers>
  <trigger
     enabled="y"
     match="You can't see a thing!"
     sequence="100"
     send_to="14"
    >
<send>last_direction_moved = nil
</send>
  </trigger>
  <trigger
     enabled="n"
     match="*left of Dimensions (c) 2000, Lunar Saber"
     name="login"
     sequence="100"
     send_to="14"
    >
<send>EnableTrigger ("get_room_name", false)
EnableTrigger ("get_description_line", false)
EnableTrigger ("Exits_Line", false)
</send>
  </trigger>
  <trigger
     enabled="n"
     match="*econnecting."
     name="reconnect"
     sequence="100"
     send_to="14"
    >
<send>DoAfterSpecial (0.5, 'EnableTrigger ("get_room_name", true)', sendto.script)
DoAfterSpecial (0.5, 'EnableTrigger ("get_description_line", true)', sendto.script)
DoAfterSpecial (0.5, 'EnableTrigger ("Exits_Line", true)', sendto.script)
</send>
  </trigger>
  <trigger
     enabled="y"
     match="^You are blinded!$"
     sequence="100"
     send_to="14"
    >
<send>EnableTrigger ("get_room_name", false)
EnableTrigger ("get_description_line", false)
EnableTrigger ("Exits_Line", false)
</send>
  </trigger>
  <trigger
     enabled="y"
     match="^You can't see a thing!$"
     sequence="100"
     send_to="14"
    >
<send>
EnableTrigger ("get_room_name", false)
EnableTrigger ("get_description_line", false)
EnableTrigger ("Exits_Line", false)
</send>
  </trigger>
  <trigger
     enabled="y"
     match="^You blink and your eyes clear.$"
     sequence="100"
     send_to="14"
    >
<send>
EnableTrigger ("get_room_name", true)
EnableTrigger ("get_description_line", true)
EnableTrigger ("Exits_Line", true)
</send>
  </trigger>
  <trigger
     enabled="y"
     match="^You rub the dirt out of your eyes.$"
     sequence="100"
     send_to="14"
    >
<send>
EnableTrigger ("get_room_name", true)
EnableTrigger ("get_description_line", true)
EnableTrigger ("Exits_Line", true)
</send>
  </trigger>
  <trigger
     enabled="n"
     match="*t)(t)(t)(t)(t)(t)(t)(t)(t)(t)(t)(t)(t)(t)(t)(t)(t)(t)(t)(t)(t)(t)(t)(t)(t)(t)"
     name="connect"
     sequence="100"
     send_to="14"
    >
<send>DoAfterSpecial (0.5, 'EnableTrigger ("get_room_name", true)', sendto.script)
DoAfterSpecial (0.5, 'EnableTrigger ("get_description_line", true)', sendto.script)
DoAfterSpecial (0.5, 'EnableTrigger ("Exits_Line", true)', sendto.script)
</send>
  </trigger>
  <trigger
  enabled="y"
  match="[Room][*][ [ DaRkNeSs ] ]"
  omit_from_output="y"
  sequence="1"
  send_to="14"
  >
<send></send>
  </trigger>
  <trigger
  enabled="y"
  match="[Last_Dir: * ]"
  name="moved_direction"
  omit_from_output="y"
  sequence="1"
  script="moved_direction"
  >
  </trigger>
  <trigger
   enabled="y"
   match="^(\s|)\[Start_Desc\]$"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="100"
  ><send>EnableTrigger ("get_description_line", true)</send>
</trigger>
  <trigger
  enabled="y"
  match="^\[Room\]\[(?<terrain>.*)\]\[ (?<name>.*) \]$"
  name="process_room_name"
  regexp="y"
  omit_from_output="y"
  sequence="100"
  send_to="14"
  >
  <send>
terrain="%1"
name="%2"
</send>
  </trigger>
  <trigger
  enabled="n"
  name="area_name"
  match="^\[Room\]\[(?P<terrain>.*)\]\[ (\w+,|\w+\s+\w+,|\w+\s+\w+\s+\w+,|)(\s+|)(?<name>(?P<area>.*)\s+-\s+(?P<room_name>.*)) \]$"
  regexp="y"
  omit_from_output="y"
  sequence="98"
  send_to="14"
  >
  <send>
terrain = GetTriggerWildcard ("area_name", "terrain")  -- get wildcard named 'terrain'
--print("Terrain: ", terrain)
--terrain="%1"
area = GetTriggerWildcard ("area_name", "area")  -- get wildcard named 'who'
--area="%2"
--print("Area: ", area)
name = GetTriggerWildcard ("area_name", "name")  -- get wildcard named 'who'
--name="%3"
--print("Name: ", name)
</send>
  </trigger>
    <trigger
  enabled="n"
  name="area_name2"
  match="^\[Room\]\[(?P<terrain>.*)\]\[ (\w+,|\w+\s+\w+,|\w+\s+\w+\s+\w+,|)(\s+|)(?<doublename>(?P<name>[^-].*), (?P<area>([^-]|\w+\s+\w+))) \]$"
  regexp="y"
  omit_from_output="y"
  sequence="98"
  send_to="14"
  >
  <send>
terrain = GetTriggerWildcard ("area_name2", "terrain")  -- get wildcard named 'terrain'
--print("Terrain: ", terrain)
--terrain="%1"
area = GetTriggerWildcard ("area_name2", "area")  -- get wildcard named 'who'
--area="%2"
--print("Area: ", area)
name = GetTriggerWildcard ("area_name2", "name")  -- get wildcard named 'who'
--name="%3"
--print("Name: ", name)
</send>
  </trigger>

  <trigger
  enabled="y"
  match="[UID]: *"
  omit_from_output="y"
  name="process_room_desc"
  sequence="100"
  script="room_number"
  >
  </trigger>
    <trigger
   enabled="y"
   match="[Exits: *]"
   omit_from_output="y"
   keep_evaluating="y"
   send_to="12"
   sequence="100"
  >
  <send>local subTable = { ["S"] = "south", ["W"] = "west", ["E"] = "east", ["U"] = "up", ["D"] = "down", ["SW"] = "sw", ["NW"] = "nw", ["NE"] = "ne", ["SE"] = "se", ["N"] = "north", ["none"] = "none " }
local result = "%1"
result = string.gsub(result, "%[", "")
result = string.gsub(result, "%]", "")

for word in string.gmatch(result, "%w+") do
    if subTable[word] then
        result = result:gsub(word, subTable[word], 1)
    end
end
Simulate("\\n[Exits2: " .. result .. "]\\n")</send>
  </trigger>
  <trigger
  enabled="y"
  match="[Exits2: * ]"
  omit_from_output="y"
  name="Exits_Line"
  sequence="100"
  send_to="14"
  >
  <send>process_exits("%1")</send>
  </trigger>
  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^\s*[a-zA-Z\~\.\+\;\,\_\-\`\'\d][^\n].*$"
   name="get_room_name"
   script="process_room_name"
   regexp="y"
   sequence="90"
   send_to="14"
  ><send></send>
  </trigger>
  <trigger
     keep_evaluating="y"
     match="^(.*|\s.*)$"
     name="get_description_line"
     script="process_description_line"
     sequence="100"
     regexp="y"
     send_to="14"
    ><send></send>
  </trigger>
  <trigger
     enabled="y"
     match="(] Exits: * [)"
     name="got_exits1"
     sequence="100"
     send_to="14"
    >
<send>EnableTrigger ("get_description_line", false)
</send>
  </trigger>
  <trigger
  enabled="y"
  match="Alas, you cannot go that way."
  script="cannot_walk"
  sequence="100"
  ></trigger>
  <trigger
  enabled="y"
  match="You can't float."
  script="cannot_walk"
  sequence="100"
  ></trigger>
  <trigger
  enabled="y"
  match="* would be left behind."
  script="cannot_walk"
  sequence="100"
  ></trigger>
  <trigger
  enabled="y"
  match="You are too exhausted to continue your stealthy movement!"
  script="cannot_walk"
  sequence="100"
  ></trigger>
  <trigger
  enabled="y"
  match="You are too exhausted."
  script="cannot_walk"
  sequence="100"
  ></trigger>
  <trigger
  enabled="y"
  match="You follow * *."
  script="cannot_walk"
  sequence="100"
  ></trigger>
  <trigger
  enabled="y"
  match="You'll have to climb to go there."
  script="cannot_walk"
  sequence="100"
  ></trigger>
  <trigger
  enabled="y"
  match="You can't just walk away from a fight!"
  script="cannot_walk"
  sequence="100"
  ></trigger>
  <trigger
  enabled="y"
  match="The * is closed."
  script="cannot_walk"
  sequence="100"
  ></trigger>
  <trigger
  enabled="y"
  match="You slam face-first into the door on your way *.  WHAM!"
  script="cannot_walk"
  sequence="100"
  ></trigger>
  <trigger
  enabled="y"
  match="You drunkenly slam face-first into the wall on your way *.  WHAM!"
  script="cannot_walk"
  sequence="100"
  ></trigger>
  <trigger
  enabled="y"
  match="You almost go *, but suddenly realize that there's no exit there."
  script="cannot_walk"
  sequence="100"
  ></trigger>
  <trigger
  enabled="y"
  match="You almost go *, but suddenly realize that the door is closed."
  script="cannot_walk"
  sequence="100"
  ></trigger>
  <trigger
  enabled="y"
  match="You need a boat to go there."
  script="cannot_walk"
  sequence="100"
  ></trigger>
  <trigger
  enabled="y"
  match="You can't drive this vehicle into water."
  script="cannot_walk"
  sequence="100"
  ></trigger>
  <trigger
  enabled="y"
  match="You can't drive this vehicle indoors."
  script="cannot_walk"
  sequence="100"
  ></trigger>
  <trigger
  enabled="y"
  match="You need to be able to swim or be on a seaworthy vehicle to go there."
  script="cannot_walk"
  sequence="100"
  ></trigger>
  <trigger
  enabled="y"
  match="No way!  You are still fighting!"
  script="cannot_walk"
  sequence="100"
  ></trigger>
  <trigger
  enabled="y"
  match="Maybe you should finish fighting first?"
  script="cannot_walk"
  sequence="100"
  ></trigger>
  <trigger
  enabled="y"
  match="The wind is roaring in from the *, pushing you back."
  script="cannot_walk"
  sequence="100"
  ></trigger>
  <trigger
  enabled="y"
  match="You can't drive this vehicle into empty air."
  script="cannot_walk"
  sequence="100"
  ></trigger>
  <trigger
   enabled="y"
   match="^The (door|gate) is closed\.$"
   regexp="y"
   name="Door_Closed"
   script="Door_Closed"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="y"
   match="The wooden door is closed."
   regexp=""
   name="woodendoor_closed"
   script="Door_Closed"
   sequence="100"
  >
  </trigger>
<trigger 
   enabled="y" 
   match="^{Where (.*)}\w{1,2}(?:.*->)?\s+(.*)$" 
   regexp="y" 
   name="InfoUpdate" 
   script="updateRoomInfo" 
   sequence="100"
>
</trigger>
</triggers>

<!--  Timers  -->

<timers>
    <timer
	   name="backup_timer"
	   enabled="y"
	   script="backup_db"
	   hour="1" minute="01" second="59"
	   active_closed="y" >
	</timer>
</timers>

<!--  Script  -->


<script>
local show_other_areas = &show_other_areas;
<![CDATA[

mapper = require "cleftmapper"
require "serialize"
require "copytable"
require "wait"
require "utility"
require "tprint"


version = "6.02"
uid = -999
current_room=nil
current_area = -999
expected_exit=-666
from_room=""
last_direction_moved=nil
terrain = 0
area = GetVariable("area") or "<No area>"
last_backup = GetVariable("last_backup") or 0
notes = 0
default_width = 269
default_height = 335
local posx = 100
local posy = 100
local DIFFERENT_AREA_COLOUR = "#ff0000"
areaname = -999
last_direction_moved = nil
OUR_ROOM_COLOUR = tonumber(GetVariable("OUR_ROOM_COLOUR")) or 0x0000FF
NOTE_ROOM_COLOUR = tonumber(GetVariable("NOTE_ROOM_COLOUR")) or 0x90EE90
shownotes = ((GetVariable("shownotes") or "1") == "1") -- default true
tile_mode = ((GetVariable("tile_mode") or "1") == "1") -- default true
count = 0
roomcount = 0
rooms = {}
local user_terrain_colour = {}
show_areas = GetVariable("show_areas") or "No"

local cleftmush_dirs = {
	["10"] = "n",
	["12"] = "s",
	["16"] = "ne",
	["19"] = "sw",
	["18"] = "se",
	["17"] = "nw",
	["13"] = "w",
	["11"] = "e",
	["14"] = "u",
	["15"] = "d",
	["99"] = "unk" -- idk what to do here (nothing?) (i'm not sure either, maybe wait till it happens and you can duplicate it)
}

valid_direction = {
n = "n",
s = "s",
e = "e",
w = "w",
u = "u",
d = "d",
ne = "ne",
sw = "sw",
nw = "nw",
no="n",
ea="e",
so="s",
we="w",
se = "se",
north = "n",
south = "s",
east = "e",
west = "w",
up = "u",
down = "d",
northeast = "ne",
northwest = "nw",
southeast = "se",
southwest = "sw",
['in'] = "in",
out = "out",
}  -- end of valid_direction

-- for calculating the way back
local inverse_direction = {
  n = "s",
  s = "n",
  e = "w",
  w = "e",
  u = "d",
  d = "u",
  ne = "sw",
  sw = "ne",
  nw = "se",
  se = "nw",
  ['in'] = "out",
  out = "in",
  }  -- end of inverse_direction


terrain_color = {}
directions = {}

directions = {
   n=true,
   s=true,
   e=true,
   w=true,
   u=true,
   d=true,
   nw=true,
   ne=true,
   se=true,
   sw=true
}

function tile_toggle()
local tile_mode = GetVariable("tile_mode") -- default true
   if tile_mode == "0" then
Execute("mapper show tile on")
   -- Note("Tile Mode is ON: Graphical tiles will be displayed.")
--print("Tile Mode: ", tile_mode)
SaveState()
mapper.draw(current_room)
   end
if tile_mode == "1" then
    Execute("mapper show tile off")
    --  Note("Tile Mode is OFF: Graphical tiles will NOT be displayed.")
--print("Tile Mode: ", tile_mode)
SaveState()
mapper.draw(current_room)
   end
end



function show_area()
if GetTriggerOption ("area_name", "enabled") == 1 then
SetTriggerOption ("area_name", "enabled", 0)
SetTriggerOption ("area_name2", "enabled", 0)
util.print("{YArea{W names will now be hidden")
if GetTriggerOption ("area_name", "enabled") == 0 then
SetTriggerOption ("area_name", "enabled", 1)
SetTriggerOption ("area_name2", "enabled", 1)
util.print("{YArea{W names will now show")
end
end
end

function tile_show(name, line, wildcards)
   if (wildcards[2] ~= "") then
      tile_mode = (wildcards[2] == "on")
   end
   if tile_mode then
      Note("Tile Mode is ON: Graphical tiles will be displayed.")
--print("Tile Mode: ", tile_mode)
SaveState()
mapper.draw(current_room)
   else
      Note("Tile Mode is OFF: Graphical tiles will NOT be displayed.")
--print("Tile Mode: ", tile_mode)
SaveState()
mapper.draw(current_room)
   end
end

--VARIATIONS OF REGEXP FOR AREA STUFF HERE
 -- ^\[Room\]\[(?P<terrain>.*)\]\[ (\w+,|\w+\s+\w+,|\w+\s+\w+\s+\w+,|)(\s+|)(?<doublename>(?P<area>.*)\s+-\s+(?P<name>.*)|(?P<name2>.*), (?P<area2>.*)) \]$
  -- ^\[Room\]\[(?P<terrain>.*)\]\[ (\w+,|\w+\s+\w+,|\w+\s+\w+\s+\w+,|)(\s+|)(?<doublename>(?P<name>.*), (?P<area>.*)) \]$
-- -----------------------------------------------------------------
-- Here on room name
-- -----------------------------------------------------------------
function process_room_name (name, line, wildcards, styles)
  local name = line
  
  if debugging then
    ColourNote ("yellow", "", "process_room_name: " .. name)
  end -- if
    
  -- ignore exits lines
  if string.match (name, "^%(] Exits: ") then
    return
  end -- if
  
  -- ignore really long lines
  if #name > 75 then
    return
  end -- if
  --if #name < 1 then
  --return
  --end -- if
  room_name = name
  
  --EnableTrigger ("get_description_line", true)
  EnableTrigger ("get_room_name", false)
  
  desc = {}
--print("Name: ", name)
--print("Desc: ", desc)
  just_got_room_name = true
end -- got_room_name

-- -----------------------------------------------------------------
-- process_description_line : Here on one line of the description
-- -----------------------------------------------------------------
function process_description_line (name, line, wildcards)

  if Trim (line) == "" then
    return
  end -- if
  
  if debugging then
    ColourNote ("yellow", "", "process_description_line: " .. line)
  end -- if
  
  if not desc then
    ColourNote ("yellow", "", "No current description")
  end -- if
  
  if just_got_room_name then
  
    -- false alarm!
    if line:sub (1, 2) ~= "  " then
    --print("FALSE ALARM")
      just_got_room_name = false
      EnableTrigger ("get_description_line", false)
      
      exits = nil
     
      return       
    end -- if
    
  end -- if
  
  just_got_room_name = false
  
  -- add to the current description
  if Trim (line) ~= "" then
    table.insert (desc, line)  
  end -- if
      if line:match(".* is carrying%:") then
        print("Line Matched It works")
        return
else
end

end -- process_description_line



-----------------------------------------
-- ADDING TRIGGER STUFF
-----------------------------------------

function room_number(name, line, args)
	uid = args[1] -- this was in the <send> previously
	from_room = current_room or ""
	current_room = args[1]
end

function moved_direction(name, line, args)
last_direction_moved = cleftmush_dirs[args[1]] or nil
end

------------------------------------------
--Update Town Special Procedure
------------------------------------------

function updateRoomInfo(name, line, wildcards)
   local valid_flags = {["waypoint"]="waypoint", ["bank"]="bank", ["alchemyguild"]="alchemyguild", ["priest"]="priest", ["forge"]="forge", ["weaponshop"]="weaponshop", ["armorshop"]="armorshop", ["petshop"]="petshop", ["itemshop"]="itemshop", ["foodshop"]="foodshop", ["tavern"]="tavern", ["morgue"]="morgue", ["quest"]="quest", ["fountain"]="fountain", ["gato"]="gato", ["moti"]="moti", ["inn"]="inn"}
   local roomtype, room, roomuid, matchFound = wildcards[1], wildcards[2], current_room or 0, false
   new_flags = {}
   for word in wildcards[1]:gmatch("%w+") do table.insert(new_flags, word) end

   local function CheckFlags()
      for _, v in pairs(new_flags) do
	 if (valid_flags[v] == nil) then
	    return false
	 else
	    return true
	 end
      end
   end

   if room then
      for i,v in pairs(rooms) do
	 if v.name == Trim(room) then
	    roomuid = i
	    matchFound = true
	    break
	 end
      end
   else
      matchFound = true
   end

   if matchFound == true and rooms[roomuid] ~= nil then
      if (roomtype == "clear") then
	 rooms[roomuid].info = nil
	 print("Cleared flags from: ", rooms[roomuid].name)
	 add_update_room(roomuid, rooms[roomuid])
      elseif (not rooms[roomuid].info and CheckFlags()) then
	 rooms[roomuid].info = roomtype
	 add_update_room(roomuid, rooms[roomuid])
	 print("Added flags: ", roomtype)
      elseif (CheckFlags()) then
	 for k, v in pairs(new_flags) do
	    rooms[roomuid].info = rooms[roomuid].info .. " " .. v
	 end
	 add_update_room(roomuid, rooms[roomuid])
	 print("Added flags:", roomtype)
      else
	 print("Flag:", roomtype, "is not valid")
      end
   else
      print("Room not mapped!")
   end
   mapper.draw(roomuid)
end

function updateRoomName()
   newname = utils.inputbox ("Enter new name for " .. current_room, name)
print("New NAME: ", newname)
  rooms[current_room].name = newname
  add_update_room(newname, rooms[current_room])
print("current_room: ", current_room)
print("Name: ", name)
  mapper.draw(current_room)
end
function updateRoomUid()
   newuid = utils.inputbox ("Enter new UID for " .. current_room, uid)
   print("New UID: ", newuid)
   update_uid(newuid, uid)
   rooms[current_room].uid = newuid
   current_room = newuid
   print("current_room: ", current_room)
   print("UID: ", uid)
   mapper.draw(current_room)
end
 
function update_uid(newuid, olduid)
--tprint(rooms[current_room])
    sql = [[UPDATE rooms SET uid = ']]..newuid..[[' WHERE uid = ']]..olduid..[[']]
    run_sql(sql)
end


-----------------------------------------
-- NOTE CODE GOES HERE
-----------------------------------------

function room_edit_note(room, vuid, newnotes)
  if vuid == nil and current_room ~= nil then
    vuid = current_room
    room = rooms[vuid]
  end

  if vuid == nil then -- still nothing?
    print("No room received from the mud yet. Try using the 'LOOK' command first.")
    return
  end

  if newnotes == nil or newnotes == "" then
    if room.notes ~= nil and room.notes ~= "" then
      newnotes = utils.inputbox("Modify room comment (clear it to delete from database)", room.name, room.notes)
    else
      newnotes = utils.inputbox("Enter room comment (creates a note for this room)", room.name, room.notes)
    end -- if
  end

  if not newnotes then
    return
  end -- if cancelled

  if newnotes == "" then
    if room.notes == nil or room.notes == "" then
      mapper.mapprint("No comment entered, note not saved.")
      return
    else
      mapper.mapprint("Note from room " .. current_room .. " deleted. Was previously: " .. room.notes)
      rooms[current_room].notes = ""
      add_update_room(current_room, rooms[current_room])
      mapper.draw(current_room)
    end
  end

  if rooms[current_room].notes == newnotes then
    return -- no change made
  end

  local oldNote = room.note

  rooms[current_room].notes = newnotes
  add_update_room(current_room, rooms[current_room])
  mapper.draw(current_room)

  if oldNote ~= nil and #oldNote > 0 then
    mapper.mapprint("Note for room", current_room, "changed to:", newnotes)
  else
    mapper.mapprint("Note added to room", current_room, ":", newnotes)
  end
end

function shownote_toggle(name, line, wildcards)
   if (wildcards[2] ~= "") then
      shownotes = (wildcards[2] == "on")
   end
   if shownotes then
      Note("SHOWNOTES is ON: Notes added to rooms will display automatically upon entrance.")
   else
      Note("SHOWNOTES is OFF: Notes added to rooms will NOT display automatically.")
   end
end
------------------------------------------------------------------------------------------------
-- CUSTOM EXIT SHIT, HAVE FUN.. HEH.
------------------------------------------------------------------------------------------------
function map_cexits_delete (name, line, wildcards)
   local query = string.format("delete from exits where fromuid=%s and dir not in ('n','s','e','w','d','u');", fix_sql(current_room))
   run_sql(query)
   for k,v in pairs(rooms[current_room].exits) do
      if not directions[k] then
         print("Found custom exit \""..k.."\" to room "..rooms[current_room].exits[k].." \""..rooms[rooms[current_room].exits[k]].name.."\"")
         rooms[current_room].exits[k] = nil
         --rooms[current_room].exit_locks[k] = nil
      end
   end
   mapper.draw (current_room)
   print("Removed custom exits from the current room.")
end

function map_cexits_purge (name, line, wildcards)
   local query = "delete from exits where dir not in ('n','s','e','w','d','u');"
   run_sql(query)
   for k,v in pairs(rooms) do
      for l,w in pairs(v.exits) do
         if not directions[l] then
            rooms[k].exits[l] = nil
            --rooms[k].exit_locks[l] = nil
         end
      end
   end
   mapper.draw (current_room)
   print("Purged all custom exits.")
end

BASE_CEXIT_DELAY = 2

function custom_exit_list (name, line, wildcards)
   local line = ""
   local count = 0
   local query
   local display_limit = 30

   area = Trim(wildcards [1] or "")
   query = string.format("select uid, name, area, dir, touid from rooms inner join exits on rooms.uid = fromuid where lower(area) like %s and dir not in ('n','s','e','w','d','u') and fromuid not in ('*','**') order by area, uid", fix_sql("%" .. area .. "%"))

   if area == "" then
      intro = "The following rooms have custom exits:"
   else
      if area == "here" then

         if current_room and current_area then
            area = current_area
         else
            Note("CEXITS HERE ERROR: The mapper doesn't know where you are. Type 'LOOK' and try again.")
            return
         end

         query = string.format("select uid, name, area, dir, touid from rooms inner join exits on rooms.uid = fromuid where lower(area) is %s and dir not in ('n','s','e','w','d','u','nw','ne','se','sw') and fromuid not in ('*','**') order by uid", fix_sql(area))
         intro = "The following rooms in the current area have custom exits:"
      elseif area == "thisroom" then
         if not current_room then
            Note("CEXITS THISROOM ERROR: The mapper doesn't know where you are. Type 'LOOK' and try again.")
            return
         end
         query = string.format("select uid, name, area, dir, touid from rooms inner join exits on rooms.uid = fromuid where fromuid=%s and dir not in ('n','s','e','w','d','u','nw','ne','se','sw')", fix_sql(current_room))
         intro = "The following custom exits are in this room:"
      else
         intro = string.format("The following rooms in areas partially matching '%s' have custom exits:",area)
      end
   end

   hr = "| area       | room name            | rm uid  | dir            | to uid  |"
   hl = "+------------+----------------------+---------+----------------+---------+"

   -- area - room name - room uid - direction - destination uid
   fmt = "| %10.10s | %-20.20s | %7.7s | %-14.14s | %7.7s |"
   -- print ("Query: " .. query)
   world.Note ("\n"..intro)
   world.Note (hl)
   world.Note (hr)
   world.Note (hl)
  -- for row in dbnrowsWRAPPER(query) do
     for row in run_sql(query) do

      line = string.format(fmt,row.area, row.name, row.uid, row.dir, row.touid)
      Hyperlink(string.format("mapper goto %s",row.uid), line, string.format("%s",row.dir), "", "", false, NoUnderline_hyperlinks)
      print("")
      count = count + 1
      CallPlugin("abc1a0944ae4af7586ce88dc", "BufferedRepaint")
   end -- custom exits query
   world.Note (hl)
   line = string.format ("Found %s custom exits.", count)
   print (line.."\n")
end -- custom_exits_list

function change_cexit_delay(name, line, wildcards)
   temp_cexit_delay = tonumber(wildcards[1])
   if not compact_mode then Note("") end
   if temp_cexit_delay == nil or temp_cexit_delay < BASE_CEXIT_DELAY or temp_cexit_delay > 40 then
      Note("CEXIT_DELAY FAILED: Invalid delay given ("..wildcards[1].."). Must be a number from 2 to 40.")
      temp_cexit_delay = nil
   end
   Note("CEXIT_DELAY: The next mapper custom exit will have ".. (temp_cexit_delay or BASE_CEXIT_DELAY) .." seconds to complete.\n")
end

function ExecuteWithWaits(cexit_command)
   wait.make (function()
      --SendNoEcho("echo {begin running}")
      local partial_cexit_command = cexit_command
      local strbegin,strend = string.find(partial_cexit_command,";?wait%(%d*.?%d+%);?")
      while strbegin do
         strbegin,strend = string.find(partial_cexit_command,";?wait%(%d*.?%d+%);?")
         if strbegin ~= nil and strbegin ~= 1 then
            Execute(string.sub(partial_cexit_command,1,strbegin-1))
         end
         if strend then
            local wait_time = tonumber(string.match(string.sub(partial_cexit_command,strbegin,strend),"wait%((%d*.?%d+)%)"))
            --SendNoEcho("echo {mapper_wait}wait("..wait_time..")")
            line, wildcards = wait.regexp("^\\{mapper_wait\\}wait\\(([0-9]*\\.?[0-9]+)\\)",nil,trigger_flag.OmitFromOutput)
            Note("CEXIT WAIT: waiting for "..wait_time.." seconds before continuing.")
            CallPlugin("abc1a0944ae4af7586ce88dc", "BufferedRepaint")
            wait.time(wait_time)
            partial_cexit_command = string.sub(partial_cexit_command, strend+1)
         end
      end
      Execute(partial_cexit_command)
      --SendNoEcho("echo {end running}")
   end)
end

-- custom_exit function contributed by Spartacus

function custom_exit (name, line, wildcards)

   local remap = {
      n = "north",
      w = "west",
      s = "south",
      e = "east",
      u = "up",
      d = "down",
      ne = "northeast",
      nw = "northwest",
      se = "southeast",
      sw = "southwest"
   }
   local cexit_command = wildcards [1] or ""
   local cexit_start

   if cexit_command == "" then
      world.Note("Nothing to do!")
      return
   end -- if cexit_command

   -- Note: Since the addition of the ignore_exits_mismatch room flag, I think this is no longer true.
   --       Getting rid of the remap allows one to draw custom exit linkages between nomap rooms.
   ------------------------------------
   -- the current system makes standard letter exit (n,e,s,w,d,u) cexits not usable, so remap them
   -- to their long word forms
   --if remap[cexit_command] then
   --   cexit_command = remap[cexit_command]
   --end
   if current_room then
      cexit_start = current_room
   else
      world.Note("CEXIT FAILED: No room received from the mud yet. Try using the 'LOOK' command first.")
      return
   end -- if current_room

   if cexit_start == "-1" then
      world.Note ("CEXIT FAILED: You cannot link custom exits from unmappable rooms.") -- This shouldn't be possible to happen, but just in case
      return
   end

   wait.make (function()
      local cexit_delay = temp_cexit_delay or BASE_CEXIT_DELAY
      local added_waits = 0
      for wait_secs in string.gmatch(cexit_command, "wait%((%d*.?%d+)%)") do
         added_waits = added_waits + tonumber(wait_secs)
      end
      world.Note("CEXIT: WAIT FOR CONFIRMATION BEFORE MOVING.\nThis should take about "..cexit_delay+added_waits.." seconds"..(((added_waits ~= 0) and " (includes "..added_waits.." seconds in added waits)") or "")..".")
      CallPlugin("abc1a0944ae4af7586ce88dc", "BufferedRepaint")
      ExecuteWithWaits(cexit_command)

      wait.time(cexit_delay+added_waits)
      temp_cexit_delay = nil
      cexit_dest = current_room
      if cexit_dest then
         if cexit_dest == "-1" then
            world.Note ("CEXIT FAILED: You cannot link custom exits to unmappable rooms.")
         elseif cexit_dest ~= cexit_start then
            world.Note (string.format("Custom Exit CONFIRMED: %s (%s) -> %s", cexit_start, cexit_command, cexit_dest))
--print("Cexit Start: ", cexit_start)
--print("Cexit Command: ", cexit_command)
--print("Cexit Dest: ", cexit_dest)
            run_sql(string.format ("INSERT OR REPLACE INTO exits (dir, fromuid, touid) VALUES (%s, %s, %s);",
               fix_sql  (cexit_command),  -- direction (eg. "n")
               fix_sql  (cexit_start),  -- from current room
               fix_sql  (cexit_dest) -- destination room
            ))
                 -- update in-memory table
            rooms[cexit_start].exits[cexit_command] = cexit_dest
            --rooms[cexit_start].exit_locks[cexit_command] = "0"
           -- update in-memory table
      --rooms[uid].exits[cexit_command] = cexit_dest
  -- add_update_room(rooms[cexit_start].exits[cexit_command], rooms[uid])
    add_update_room(from_room, rooms[from_room])
            mapper.draw (current_room)
--print("Cexit Start: ", cexit_start)
--print("Cexit Command: ", cexit_command)
--print("Cexit Dest: ", cexit_dest)
          SaveState()
         else
            world.Note (string.format("CEXIT FAILED: Custom Exit %s leads back here!", cexit_command))
         end
      else
         world.Note ("CEXIT FAILED: Need to know where we ended up.")
      end
   end)
end -- custom_exit

last_area_requested = ""


-- -----------------------------------------------------------------
-- Here on "Exits:" line ----- we have changed rooms
-- -----------------------------------------------------------------

function process_exits (exits_str)
local show_areas = GetVariable("show_areas") or "No"
if show_areas == "Yes" then 
  EnableTrigger ("area_name", true)
  EnableTrigger ("area_name2", true)
else
  EnableTrigger ("area_name", false)
  EnableTrigger ("area_name2", false)
end
--print("Show Areas: ", show_areas)
  EnableTrigger ("get_room_name", true)
  EnableTrigger ("get_description_line", false)
	--Note("process exits")
  if current_room == from_room then
  --if #desc < 2 then
	--Note(current_room, ", ", from_room)
    --print("From Room: ", from_room)
    --print("Current Room: ", current_room)
	--Note("same room")
  --just_got_room_name = false
 --return
    end -- if

  desc = table.concat (desc, "\n")

  -- generate a "room ID" by hashing the room name, description and exits
  uid = utils.tohex (utils.md5 (name .. desc .. terrain .. exits_str))
  uid = uid:sub (1, 25) 
  -- break up exits into individual directions
  exits = {}

  for exit in string.gmatch (exits_str, "%w+") do
    local ex = valid_direction [exit]
    if ex then
      exits [ex] = "-666"  -- don't know where it goes yet
    end -- if
  end -- for
--print("Name: ", name)
--print("Desc: ", desc)
  if #desc < 2 then
 return
elseif #desc > 2200 then
 return
end -- for
Simulate("\n[UID]: ", uid)
--area = rooms[uid].area
--SetVariable("area", area)
--print("Area: ", area)
--print("Current Area: ", current_area)
--print("Name: ", name)
--print("Desc: ", desc) 
--print("Terrain: ", terrain)
--print("Current Room: ", current_room)
--print("Exits: ", exits_str)
printexits = exits_str
Simulate("\nLast Dir: ", last_direction_moved)


  -- add to table if not known
  --Note("add room to table")
  if not rooms [uid] then
   rooms [uid] = { name = name, desc = desc, exits = exits, area=area, fillcolour=terrain_color[terrain], fillbrush=0, bordercolour=0xffffff }
   add_update_room(uid, rooms[uid])
  end -- if

  -- save so we know current room later on
  current_room = uid
     -- util.print"->", rooms[uid].notes)
  --if rooms ~= nil and
   --    rooms[uid] ~= nil and
   --    rooms[uid].notes ~= nil and
   --    rooms[uid].notes ~= ""
   -- then
--       mapper.mapprint("*** MAPPER NOTE *** ->", rooms[uid].notes)
--end
  -- add exit into mapper
  --Note("add exit")
  if from_room ~= "" and last_direction_moved then -- we were in a room # that we got from kxwt, and then moved to another room
	--Note("rooms[", from_room, "].exits[", last_direction_moved, "] = ", current_room)
	rooms[from_room].exits[last_direction_moved] = current_room
    add_update_room(from_room, rooms[from_room])
	last_direction_moved = nil -- remove last direction so updating a room only happens when we walk somewhere
  end
--if last_direction_moved ~= nil then
--EnableTrigger ("get_room_name", true)
--end
   if shownotes and rooms[uid] and rooms[uid].notes ~= nil and rooms[uid].notes ~= "" then
      --AnsiNote(ColoursToANSI("{R[{WMapper Notes for room" ..name.. ..rooms[uid].notes.."{W]"))
   AnsiNote(ColoursToANSI("{R[{WNotes - {Y"..name.." {W- "..rooms[uid].notes.."{R]{w"))
end
  -- call mapper to draw this room
  mapper.draw (uid)
  just_got_room_name = false
  -- if expected_exit == "-666" and from_room then
  --    fix_up_exit ()
  -- end -- exit was wrong

  -- return
end -- process_exits

function fix_up_exit ()
   local room = rooms [from_room]

   run_sql(string.format ("UPDATE exits SET touid = %s WHERE fromuid = %s AND dir = %s;",
        fix_sql  (current_room),     -- destination room
        fix_sql  (from_room),       -- from previous room
        fix_sql  (last_direction_moved)  -- direction (eg. "n")
   ))

--   if show_database_mods then
      mapper.mapprint ("Fixed exit", last_direction_moved, "from room", from_room, "to be to", current_room)
--   end -- if

   room.exits [last_direction_moved] = current_room

   last_direction_moved = nil
   from_room = nil
end -- fix_up_exit

-- -----------------------------------------------------------------
-- for converting things like ^ $ * etc. into "escaped" sequences
-- -----------------------------------------------------------------
function fix_regexp_magic_characters (r)
    return string.gsub (r, "[%^%$%(%)%%%.%[%]%*%+%-%?]", "%%%1")
end -- fix_regexp_magic_characters

-- -----------------------------------------------------------------
-- mapper 'get_room' callback - it wants to know about room uid
-- -----------------------------------------------------------------

function get_room (uid)


  if not rooms [uid] then
   return nil
  end -- if

  local room = copytable.deep (rooms [uid])
   local notes = ""
   if room.notes and room.notes ~= "" then
      notes = "\nNote: " .. room.notes
   end -- if notes

  local texits = {}
  for dir in pairs (room.exits) do
    table.insert (texits, dir)
  end -- for
  table.sort (texits)

  if uid == current_room then
  current_area = room.area or "Cleft of Dimensions"  -- assume every room is in this area
    --current_area = room.area
  end -- if
  --room.area = "Cleft of Dimensions"  -- assume every room is in this area
  room.hovermessage = string.format (
"%s\tExits: %s\nRoom: %s\nDescription: %s \nArea: %s\nTerrain:%s \nNotes: %s",
      room.name,
      table.concat (texits, ", "),
      uid,
      room.desc,
      room.area,
      terrain,
      room.notes
      -- depth,
      -- table.concat (path, ",")
      )


	    -- SPECIAL ROOM COLOUR FILLS: Marking a room as "special" makes the border get thicker when you walk into a room
special_room = false
shop = false
                         if room.info and room.info ~= "" then
                         if string.match (room.info, "waypoint") then
                                         special_room = true
                         elseif string.match (room.info, "bank") then
                                         special_room = true
                         elseif string.match (room.info, "alchemyguild") then
                                         special_room = true
                         elseif string.match (room.info, "priest") then
                                         special_room = true
                         elseif string.match (room.info, "forge") then
                                         special_room = true
                         elseif string.match (room.info, "weaponshop") then
                                         special_room = true
                                                 shop = true
                         elseif string.match (room.info, "armorshop") then
                                         special_room = true
                                                 shop = true
                         elseif string.match (room.info, "petshop") then
                                         special_room = true
                                                 shop = true
                         elseif string.match (room.info, "itemshop") then
                                         special_room = true
                                                 shop = true
                         elseif string.match (room.info, "foodshop") then
                                         special_room = true
                                                 shop = true
                         elseif string.match (room.info, "tavern") then
                                         special_room = true
                                                 shop = true
				         elseif string.match (room.info, "morgue") then
                                         special_room = true		
                         elseif string.match (room.info, "quest") then
                                         special_room = true			
                         elseif string.match (room.info, "fountain") then
                                         special_room = true		
                         elseif string.match (room.info, "gato") then
                                         special_room = true		
                         elseif string.match (room.info, "moti") then
                                         special_room = true			
                         elseif string.match (room.info, "inn") then
                                         special_room = true	 								 
                 
										end
end -- if
					     if uid == current_room and special_room then
                                         room.bordercolour = mapper.OUR_ROOM_COLOUR.colour
                                         room.borderpenwidth = 3		 
   elseif room.area ~= current_area then
    room.bordercolour = ColourNameToRGB "red"
  end -- not in this area
  return room


end -- get_room

function config_our_room_colour ()
		local clr = PickColour(OUR_ROOM_COLOUR or 0)
		if clr ~= -1 then
			OUR_ROOM_COLOUR = clr
            mapper.OUR_ROOM_COLOUR.colour = clr
			SaveState()
		end
end

function config_note_colour ()
		local clr = PickColour(NOTE_ROOM_COLOUR)
		if clr ~= -1 then
			NOTE_ROOM_COLOUR = clr
            mapper.NOTE_ROOM_COLOUR.colour = clr
			SaveState()
		end
end

function room_click (uid, flags)

   -- check we got room at all
   if not uid then
      return nil
   end -- if

   -- look it up
   local room = rooms [uid]

   -- not cached - see if in database
   if not room then
return
   end -- not in cache

   if not room then
      return
   end -- if still not there

  local function checkmark (which)
    if rooms [uid] [which] then
      return "+"
    else
      return ""
    end -- if
  end -- checkmark


  local handlers = {
     -- { name = "(NOT-YET-IMPLEMENTED)Edit bookmark", func = room_edit_bookmark} ,
    --  { name = "-", } ,
    --  { name = "(NOT-YET-IMPLEMENTED)Add Exit",    func = room_add_exit} ,
      { name = "Change Exit", func = room_change_exit} ,
      { name = "Delete Current Room", func = delete_room_click} ,
	  { name = "Current Room Border Color", func = config_our_room_colour} ,
	  { name = "Note Room Border Color", func = config_note_colour} ,
      { name = "Toggle Graphical Tiles", func = tile_toggle} ,
      { name = "-", } ,
      { name = checkmark ("shop")  .. "Mark as Weapon Shop",   func = room_toggle_weaponshop } ,
      { name = checkmark ("shop")  .. "Mark as Armor Shop",    func = room_toggle_armorshop } ,
      { name = checkmark ("shop")  .. "Mark as Food Shop",     func = room_toggle_foodshop } ,
      { name = checkmark ("shop")  .. "Mark as Item Shop",     func = room_toggle_itemshop } ,
      { name = checkmark ("shop")  .. "Mark as Pet Shop",      func = room_toggle_petshop } ,
      { name = checkmark ("shop")  .. "Mark as Tavern",        func = room_toggle_tavern } ,
      { name = checkmark ("shop")  .. "Mark as Inn",           func = room_toggle_inn } ,
     } -- handlers

  local t, tf = {}, {}
  for _, v in pairs (handlers) do
    table.insert (t, v.name)
    tf [v.name] = v.func
  end -- for

  local choice = WindowMenu (mapper.win,
                            WindowInfo (mapper.win, 14),
                            WindowInfo (mapper.win, 15),
                            table.concat (t, "|"))

  local f = tf [choice]

  if f then
    f (room, uid)
  end -- if handler found

end -- room_click


function room_toggle_weaponshop()
Execute ("mapper flag weaponshop")
end -- room_toggle_weaponshop

function room_toggle_armorshop()
Execute ("mapper flag armorshop")
end -- room_toggle_armorshop

function room_toggle_foodshop()
Execute ("mapper flag foodshop")
end -- room_toggle_foodshop

function room_toggle_itemshop()
Execute ("mapper flag itemshop")
end -- room_toggle_itemshop

function room_toggle_petshop()
Execute ("mapper flag petshop")
end  -- room_toggle_petshop

function room_toggle_tavern()
Execute ("mapper flag tavern")
end -- room_toggle_tavern

function room_toggle_inn()
Execute ("mapper flag inn")
end -- room_toggle_inn

-- -----------------------------------------------------------------
-- map_find: mapper find xxx
-- -----------------------------------------------------------------
function map_find (name, line, wildcards)

--  mapper.mapprint (string.rep ("-", 25) .. " Mapper search " .. string.rep ("-", 25))
  local reset = ANSI (0)
  local bold = ANSI (1)
  local unbold = ANSI (22)

  local matches = { }
  local count = 0
  local target = Trim (wildcards [1]:lower ())
  util.print("{R-------------------------------------------------------")
  util.print("            {D[{WSearching rooms for {D'{Y".. target .. "{D']")
  util.print("{R-------------------------------------------------------")
  if target == "" then
    mapper.maperror ("No search string specified")
    return
  end -- if

  if not mapper.check_we_can_find () then
    return
  end -- if find not OK

  -- fix up any regular expression "magic" letters to be escaped by a %
  local fixed_target = fix_regexp_magic_characters (target)

  -- fix up for caseless searches in the room description (eg. "a" becomes "[aA]")
  local caseless_target = string.gsub (fixed_target, "(%a)", function (a)
      return "[" .. a:lower () .. a:upper () .. "]"
      end -- function
      )

  -- do a simple string search to find matching rooms
  for k, v in pairs (rooms) do

    -- don't want nil descriptions
    if not v.description then
      v.description = ""
    end -- if no description

    if string.find (v.name:lower (), fixed_target) or
       string.find (v.description:lower (), fixed_target) then
      matches [k] = true
      count = count + 1
    end -- if match
  end -- for each room

  local function show_snippet (uid)
    local room = rooms [uid]
     if not room then
       return
     end -- if

    -- don't bother if the wanted words was in the room name
    if string.find (room.name:lower (), fixed_target) then
      return
    end -- if

    -- otherwise show the wanted word in the description, in bold
    AnsiNote (reset .. string.gsub (room.desc, caseless_target, bold .. "%1" .. unbold))

  end -- show_snippet

  -- see if nearby
  mapper.find (
    function (uid)
      local room = matches [uid]
      if room then
        matches [uid] = nil
      end -- if
      return room, next (matches) == nil
    end,  -- function
    show_vnums,  -- show vnum?
    count,      -- how many to expect
    false,      -- don't auto-walk
    show_snippet  -- show find snippet
    )
end -- map_find

-- -----------------------------------------------------------------
-- note_find: note find xxx
-- -----------------------------------------------------------------
function note_find (name, line, wildcards)

  --mapper.mapprint (string.rep ("-", 25) .. " Mapper search " .. string.rep ("-", 25))
  local reset = ANSI (0)
  local bold = ANSI (1)
  local unbold = ANSI (22)

  local matches = { }
  local count = 0
  local target = Trim (wildcards [1]:lower ())
    util.print("{R-------------------------------------------------------")
  util.print("            {D[{WSearching notes for {D'{Y".. target .. "{D']")
    util.print("{R-------------------------------------------------------")
  if target == "" then
    mapper.maperror ("No search string specified")
    return
  end -- if

  if not mapper.check_we_can_find () then
    return
  end -- if find not OK

  -- fix up any regular expression "magic" letters to be escaped by a %
  local fixed_target = fix_regexp_magic_characters (target)

  -- fix up for caseless searches in the room description (eg. "a" becomes "[aA]")
  local caseless_target = string.gsub (fixed_target, "(%a)", function (a)
      return "[" .. a:lower () .. a:upper () .. "]"
      end -- function
      )
  -- do a simple string search to find matching rooms
  for k, v in pairs (rooms) do

    -- don't want nil descriptions
    if not v.description then
      v.description = ""
    end -- if no description

    if ((v.notes ~= nil) and (string.find (v.notes:lower (), fixed_target) or string.find (v.description:lower (), fixed_target))) then
      matches [k] = true
      count = count + 1
    end -- if match
  end -- for each room

  local function show_snippet (uid)
    local room = rooms [uid]
     if not room then
       return
     end -- if

    -- don't bother if the wanted words was in the room name
    if string.find (room.name:lower (), fixed_target) then
      return
    end -- if

    -- otherwise show the wanted word in the description, in bold
    AnsiNote (reset .. string.gsub (room.notes, caseless_target, bold .. "%1" .. unbold))

  end -- show_snippet

  -- see if nearby
  mapper.find (
    function (uid)
      local room = matches [uid]
      if room then
        matches [uid] = nil
      end -- if
      return room, next (matches) == nil
    end,  -- function
    show_vnums,  -- show vnum?
    count,      -- how many to expect
    false,      -- don't auto-walk
    show_snippet  -- show find snippet
    )
end -- note_find

-- -----------------------------------------------------------------
-- note_find: desc find xxx
-- -----------------------------------------------------------------
function desc_find (name, line, wildcards)

  --mapper.mapprint (string.rep ("-", 25) .. " Mapper search " .. string.rep ("-", 25))
  local reset = ANSI (0)
  local bold = ANSI (1)
  local unbold = ANSI (22)

  local matches = { }
  local count = 0
  local target = Trim (wildcards [1]:lower ())
    util.print("{R-------------------------------------------------------")
  util.print("         {D[{WSearching descriptions for {D'{Y".. target .. "{D']")
    util.print("{R-------------------------------------------------------")
  if target == "" then
    mapper.maperror ("No search string specified")
    return
  end -- if

  if not mapper.check_we_can_find () then
    return
  end -- if find not OK

  -- fix up any regular expression "magic" letters to be escaped by a %
  local fixed_target = fix_regexp_magic_characters (target)

  -- fix up for caseless searches in the room description (eg. "a" becomes "[aA]")
  local caseless_target = string.gsub (fixed_target, "(%a)", function (a)
      return "[" .. a:lower () .. a:upper () .. "]"
      end -- function
      )
  -- do a simple string search to find matching rooms
  for k, v in pairs (rooms) do

    -- don't want nil descriptions
    if not v.description then
      v.description = ""
    end -- if no description

    if string.find (v.desc:lower (), fixed_target) or
       string.find (v.description:lower (), fixed_target) then
      matches [k] = true
      count = count + 1
    end -- if match
  end -- for each room

  local function show_snippet (uid)
    local room = rooms [uid]
     if not room then
       return
     end -- if

    -- don't bother if the wanted words was in the room name
    if string.find (room.name:lower (), fixed_target) then
      return
    end -- if

    -- otherwise show the wanted word in the description, in bold
    AnsiNote (reset .. string.gsub (room.desc, caseless_target, bold .. "%1" .. unbold))

  end -- show_snippet

  -- see if nearby
  mapper.find (
    function (uid)
      local room = matches [uid]
      if room then
        matches [uid] = nil
      end -- if
      return room, next (matches) == nil
    end,  -- function
    show_vnums,  -- show vnum?
    count,      -- how many to expect
    false,      -- don't auto-walk
    show_snippet  -- show find snippet
    )
end -- desc_find

-- -----------------------------------------------------------------
-- map_goto for: mapper goto xxx
-- -----------------------------------------------------------------
function map_goto (name, line, wildcards)
  local wanted = wildcards [1]
  -- check valid string
  if string.match (wanted, "%D") then
    mapper.maperror ("Room number must be numeric, you entered: " .. wanted)
    return
  end -- if

  -- see if already there
  if current_room and string.match (current_room, "^" .. wanted) then
    mapper.mapprint ("You are already in that room.")
    return
  end -- if
  -- find desired room
  mapper.find (
    function (uid)
      local found = string.match (uid, "^" .. wanted)
      return found, found
    end,  -- function
    show_vnums,  -- show vnum?
    1,          -- how many to expect
    true        -- just walk there
    )
end -- map_goto

function map_resume (name, line, wildcards)
 
  local wanted = mapper.last_hyperlink_uid or mapper.last_speedwalk_uid
 
  if not wanted then
    mapper.print "No outstanding speedwalks or hyperlinks."
    return
  end -- if nothing to do
 
  -- find desired room
  mapper.find (
    function (uid)
      return uid == wanted, uid == wanted  
    end,  -- function
    show_vnums,  -- show vnum?
    1,      -- how many to expect
    true    -- just walk there
    )
       
end -- map_resume

-- -----------------------------------------------------------------
-- map_where: Show where a room is
-- -----------------------------------------------------------------
function map_where (name, line, wildcards)
  if not mapper.check_we_can_find () then
    return
  end -- if
  local wanted = wildcards [1]
  if current_room and wanted == current_room then
    mapper.mapprint ("You are already in that room.")
    return
  end -- if
  local paths = mapper.find_paths (current_room,
           function (uid)
             return uid == wanted,  -- wanted room?
                    uid == wanted   -- stop searching?
            end)
  local uid, item = next (paths, nil) -- extract first (only) path
  -- nothing? room not found
  if not item then
    mapper.mapprint (string.format ("Room %s not found", wanted))
    return
  end -- if
  -- turn into speedwalk
  local path = mapper.build_speedwalk (item.path)
  -- display it
  mapper.mapprint (string.format ("Path to %s is: %s", wanted, path))
end -- map_where

-- -----------------------------------------------------------------
-- cannot_walk - we tried to walk but failed
-- -----------------------------------------------------------------
function cannot_walk (name, line, wildcards)
  mapper.cancel_speedwalk ()
  just_got_room_name = false 
  last_direction_moved = nil
  EnableTrigger ("get_room_name", true)
  EnableTrigger ("get_description_line", false)

  
  
--  mapper.mapprint ("Attempt to walk cancelled.")

end -- cannot_walk
function check_for_cannot_go (name, line, wildcards)
  if cannot_move_messages [line] then
    cannot_walk ()
  end -- if
end -- check_for_cannot_go

 --function OnPluginSent (sText)
--  if valid_direction [sText] then
--    last_direction_moved = valid_direction [sText]
    -- Note("Just moved", last_direction_moved)
--   if current_room and rooms [current_room] then
--      expected_exit = rooms [current_room].exits [last_direction_moved]
--     if expected_exit then
--        from_room = current_room
--      end -- if
    -- Note("expected exit for this direction is to room", expected_exit)
--    end -- if
--  end -- if 
 --end -- function


function confirm_delete_area(a)
	response = utils.umsgbox("Delete area: "..a.."?", "Delete Area", "okcancel", "?", 2)
	if response == "ok" then
		delete_area(a)
	end
end

function Door_Closed (name, line, wildcards)

local dirs =  {
  n = "north",
  s = "south",
  e = "east",
  w = "west",
  u = "up",
  d = "down",
  ne = "northeast",
  sw = "southwest",
  nw = "northwest",
  se = "southeast",
  ['in'] = "in",
  out = "out",
  }  -- end of available
  
  if last_direction_moved then
    Execute ("open " .. dirs [last_direction_moved])
    Execute (dirs [last_direction_moved])
  end -- if
  
end -- Door_Closed


-- -----------------------------------------------------------------
-- check_for_cannot_go - look up the line in a table of failure messages
-- see table: cannot_move_messages
-- -----------------------------------------------------------------
function check_for_cannot_go (name, line, wildcards)

  for _, v in ipairs (cannot_move_messages) do
    if string.find (line, v) then
      cannot_walk ()
      break
    end -- if match
  end -- for each message
end -- check_for_cannot_go

function findpathfast(name, line, wildcards)
   local src = wildcards[1]
   local dest = wildcards[2]
   rooms[src] = load_room_from_database(src)
   rooms[dest] = load_room_from_database(dest)

   if rooms[src] == nil then
      mapper.mapprint (string.format ("Room %s not known.", src))
   end
   if rooms[dest] == nil then
      mapper.mapprint (string.format ("Room %s not known.", dest))
   end
   if rooms[src] == nil or rooms[dest] == nil then
      return
   end

   local foundpath = findpath(src, dest)
   if foundpath == nil then
      mapper.mapprint (string.format ("Path from %s to %s not found.", wildcards[1], wildcards[2]))
      return
   end

   -- turn into speedwalk
   local speedwalk = mapper.build_speedwalk (foundpath, speedwalk_prefix)

   -- display it
   if speedwalk ~= nil then
      mapper.mapprint (string.format ("Path from %s to %s is: %s", wildcards[1], wildcards[2], speedwalk))
   else
      mapper.mapprint ("Pick different start and end rooms.")
   end
end

function blackindigoPrint(msg)
	ColourNote("blueviolet","black",msg)
end
function blackredPrint(msg)
	ColourNote("black","red",msg)
end
function whiteindigoPrint(msg)
	ColourNote("white","indigo",msg)
end


function setup_terrain_colors()
terrain_color["0"]=tonumber("0x000000")--NOTSET
terrain_color["inside"]=tonumber("0x606060")--Inside
terrain_color["city"]=tonumber("0x907040")--City
terrain_color["field"]=tonumber("0x00ff00")--Field
terrain_color["forest"]=tonumber("0x008000")--Forest
terrain_color["hills"]=tonumber("0x409040")--Hills
terrain_color["mountain"]=tonumber("0xc0c0c0")--Mountain
terrain_color["mount2"]=tonumber("0x406080")--Mount2
terrain_color["swim"]=ColourNameToRGB("blue")--Swim
terrain_color["water"]=ColourNameToRGB("blue")--Water
terrain_color["noswim"]=ColourNameToRGB("darkblue")--NoSwim
terrain_color["unused"]=tonumber("0xc0c0c0")--Unused
terrain_color["air"]=tonumber("0x808080")--Air
terrain_color["desert"]=tonumber("0x00ffff")--Desert (proper color)
terrain_color["swamp"]=tonumber("0x406080")--Swamp
terrain_color["road"]=ColourNameToRGB("saddlebrown")--Road
terrain_color["enter"]=tonumber("0x606060")--Enter   
terrain_color["snow"]=ColourNameToRGB("navajowhite")--Snow
terrain_color["rock"]=tonumber("0x808080")--Rock
terrain_color["jungle"]=tonumber("0x20c040")--Jungle
terrain_color["ruins"]=tonumber("0x806060")--Ruins
terrain_color["coastline"]=ColourNameToRGB("blue")--Coastal
terrain_color["developed"]=tonumber("0x021e6c")--Developed
terrain_color["void"]=tonumber("0x303030")--Void
terrain_color["lava"]=ColourNameToRGB("red")--Lava
 -- end of terrain_color
end


-- -----------------------------------------------------------------
-- Plugin Install
-- -----------------------------------------------------------------

function OnPluginInstall ()

  config = {}  -- in case not found
  setup_terrain_colors()

  -- get saved configuration
  assert (loadstring (GetVariable ("config") or "")) ()

  -- and rooms
  --assert (loadstring (GetVariable ("rooms") or "")) ()

  -- new stuff for sql data
  check_create_db()
  load_rooms()

  -- initialize mapper

  mapper.init { config = config,
                get_room = get_room, findpath = findpath,
                room_click = room_click,    -- called on RH click on room square,
                show_help = mapperhelp,         -- to show help,
                show_other_areas = show_other_areas,  -- want to see areas other than the current one?
}
      util.print("{YC{yl{Ye{yf{Yt{RM{rU{RS{rH {RG{Yr{Ga{Cp{Bh{Mi{mc{Ra{Yl {x238Mapper installed: {Gv" .. version)


end -- OnPluginInstall


------------------------------------------------------------------------------------------------------------
---------------------------------- SUPER MAPPER HELP PAGES HERE --------------------------------------------
------------------------------------------------------------------------------------------------------------
function mapperhelp()
      util.print("{W--------------------------------------------------------------------------------")
      util.print("{WPlugin Name  : {YC{yl{Ye{yf{Yt{RM{rU{RS{rH {RG{Yr{Ga{Cp{Bh{Mi{mc{Ra{Yl {x238Mapper")
      util.print("{WAuthor       : {x238Asmodeus")
      util.print("{WVersion      : {G" .. version)
      util.print("{W--------------------------------------------------------------------------------")
      util.print("")
      util.print("                 {YC{yl{Ye{yf{Yt{RM{rU{RS{rH {x238Mapper Help: {YIndex                            ")
      util.print("{R================================================================================")
      util.print("")
      util.print("{W {x238Dimmed{W options are currently {x238unavailable")
      util.print("")
      util.print("{Y mapper help               {R-->{W Show this list")
      util.print("{Y mapper help config        {R-->{W Commands for configuring the mapper")
      util.print("{Y mapper help exits         {R-->{W Commands for setting custom exits")
      util.print("{Y mapper help moving        {R-->{W Commands for moving between rooms")
      util.print("{Y mapper help utils         {R-->{W Other utilitarian commands")
      util.print("{Y mapper help flags         {R-->{W Commands to set flags on rooms")
      util.print("{x238 mapper help searching     --> Used for finding notes, shops, banks, etc")
      util.print("")
      util.print("{R================================================================================")
      util.print("")
end

function mapperhelpconfig()
      util.print("{W--------------------------------------------------------------------------------")
      util.print("                 {YC{yl{Ye{yf{Yt{RM{rU{RS{rH {x238Mapper Help: {YConfiguration                            ")
      util.print("{W--------------------------------------------------------------------------------")
      util.print("")
      util.print("{W Click the {Rasterisk{W or {Rquestion mark{W on the top left or right of the mapper")
      util.print("")
      util.print("{Y mapper zoom out           {R-->{W Zooms out your view of the map")
      util.print("{Y mapper zoom in            {R-->{W Zooms in your view of the map")
      util.print("{Y mapper hide               {R-->{W Hides the mapper window")
      util.print("{Y mapper show               {R-->{W Unhides the mapper window")
      util.print("{Y mapper config roomcolor   {R-->{W Changes the border color of our current room")
      util.print("")
      util.print("{W--------------------------------------------------------------------------------")
      util.print("")
end

function mapperhelpexits()
      util.print("{W--------------------------------------------------------------------------------")
      util.print("                 {YC{yl{Ye{yf{Yt{RM{rU{RS{rH {x238Mapper Help: {YExits                            ")
      util.print("{W--------------------------------------------------------------------------------")
      util.print("")
      util.print("{W {x238Dimmed{W options are currently {x238unavailable")
      util.print("")
      util.print("{x238 mapper cexits             --> Lists known custom exits")
      util.print("{x238 mapper cexits <here/area> --> List known custom exits here or in another area")
      util.print("{Y mapper cexit <command>    {R-->{W Follow and link a custom exit")
      util.print("{Y                              {W To insert a pause during execution of the cexit,")
      util.print("{Y                              {W use wait(<seconds>) as one or more of the cexit moves")
      util.print("{Y                              {W To stack commands, use {Y;;{W as separator to get around")
      util.print("{Y                              {W the line break parser (ex: '{Ymapper cexit open south;;south{W')")
      util.print("{Y mapper delete cexits      {R-->{W Remove the custom exits from this room")
      util.print("{x238 mapper purge cexits       --> Remove ALL custom exits")
      util.print("{Y mapper cexit_wait seconds {R-->{W Wait this number of seconds instead of the standard 2 ")
      util.print("{Y                              {W when constructing the next cexit (between 2 and 30)")
      util.print("")
      util.print("{W--------------------------------------------------------------------------------")
      util.print("")
end

function mapperhelpmoving()
      util.print("{W--------------------------------------------------------------------------------")
      util.print("                 {YC{yl{Ye{yf{Yt{RM{rU{RS{rH {x238Mapper Help: {YMoving                            ")
      util.print("{W--------------------------------------------------------------------------------")
      util.print("")
      util.print("{Y mapper goto <uid>         {R-->{W Walks to the specified UID. Use {Ymapper print uid")
      util.print("{Y                              {W to get the UID of your current room, or click the")
      util.print("{Y                              {W asterisk on the top left of the map and enable")
      util.print("{Y                              {W the {YShow Room ID option")
      util.print("{Y mapper find <keyword> {Wor  {R-->{W Finds all rooms with the given keywords within")
      util.print("{Y find <keyword>               {W a 300 room radius. Click the desired link to")
      util.print("{Y                              {W begin the walk towards your destination")
      util.print("{Y mapper resume{W or {Ygo       {R-->{W Resumes any interrupted speedwalk")
      util.print("{Y mapper stop{W or {Ystop       {R-->{W Immediately stops any active speedwalk")
      util.print("")
      util.print("{W--------------------------------------------------------------------------------")
      util.print("")
end

function mapperhelputils()
      util.print("{W--------------------------------------------------------------------------------")
      util.print("                 {YC{yl{Ye{yf{Yt{RM{rU{RS{rH {x238Mapper Help: {YUtils                            ")
      util.print("{W--------------------------------------------------------------------------------")
      util.print("")
      util.print("{Y mapper print              {R-->{W Prints a list of the UID, name, terrain, exits,")
      util.print("{Y                              {W area, and room flags from your current room")
      util.print("{Y mapper show explored      {R-->{W Shows the amount of rooms explored in the game")
      util.print("{Y mapper print uid          {R-->{W Prints the UID of the current room")
      util.print("{Y mapper backup             {R-->{W Instantly creates a backup of the map database")
      util.print("{Y mapper addnote            {R-->{W Adds a new note for the current room. Erase all")
      util.print("{Y                              {W text to remove a note from a room")
      util.print("{Y mapper addnote <note>     {R-->{W Adds a new note, but skips the entry box")
      util.print("{Y mapper shownotes [on/off] {R-->{W Toggles display of notes upon entering a room")
      util.print("{Y mapper show tile [on/off] {R-->{W Toggles display of graphical tiles")
      util.print("{Y mapper delete room        {R-->{W Deletes the current room you're in")
      util.print("{Y mapper delete room <uid>  {R-->{W Deletes the designated room")
      util.print("{Y mapper where <uid>        {R-->{W Shows directions to the designated room")
      util.print("")
      util.print("{W--------------------------------------------------------------------------------")
      util.print("")
end

function mapperhelpflags()
      util.print("{W--------------------------------------------------------------------------------")
      util.print("                 {YC{yl{Ye{yf{Yt{RM{rU{RS{rH {x238Mapper Help: {YFlags            ")
      util.print("{W--------------------------------------------------------------------------------")
      util.print("")
      util.print("{Y mapper flag [flag/clear]  {R-->{W Appends or clears a flag to the current room")
      util.print("")
      util.print("{Y Valid flags               {R-->{W waypoint, bank, alchemyguild, priest, forge")
      util.print("{Y                              {W weaponshop, armorshop, petshop, itemshop")
      util.print("{Y                              {W foodshop, tavern, morgue, quest, fountain, gato")
      util.print("{Y                              {W moti, inn")
      util.print("")
      util.print("{W--------------------------------------------------------------------------------")
      util.print("")
end

-- -----------------------------------------------------------------
-- Plugin Save State
-- -----------------------------------------------------------------

function OnPluginSaveState ()
  mapper.save_state ()
  SetVariable ("config", "config = " .. serialize.save_simple (config))
  SetVariable("last_backup", last_backup)
SetVariable("OUR_ROOM_COLOUR", OUR_ROOM_COLOUR) -- Color of Room Border
SetVariable("NOTE_ROOM_COLOUR", NOTE_ROOM_COLOUR) -- Color of Room Border
   SetVariable("shownotes", shownotes and "1" or "0")
   SetVariable("tile_mode", tile_mode and "1" or "0")
end -- OnPluginSaveState

------------------------------------------
-- start of sql additions
------------------------------------------
function delete_room_alias(name, line, wildcards)
	local num = wildcards[1]
	if num then
		delete_room(num)
	end
end

function delete_room_click(name, line, wildcards)
	local num = current_room
	if num then
		delete_room(num)
	end
end

function delete_area_alias(name, line, wildcards)
	local a = wildcards[1]
	if a then
		delete_area(a)
	end
end

function delete_room(num) -- delete room from rooms
	for r, tbl in pairs(rooms) do -- for each room in table
		if tostring(r) == tostring(num) then
			rooms[r] = nil -- setting table item to nil deletes it
		end
	end
	run_sql([[DELETE FROM rooms WHERE uid = ']]..num..[[']])
	Note("Deleted ", num, ".")
	SendNoEcho("look")
end

function delete_area(a)
	local cnt = 0
	for r, tbl in pairs(rooms) do -- for each room in table
		if tostring(tbl.area) == tostring(a) then
			rooms[r] = nil -- setting table item to nil deletes it
			cnt = cnt + 1
		end
	end
	run_sql([[DELETE FROM rooms WHERE area = ']]..fix_sql(a)..[[']])
	Note("Deleted ", cnt, " rooms in '", a, "' area.")
end

function clean_file_name(f)
	f = string.gsub(f, "[^%w]", "")
	return f
end

function fix_sql(s)
	if not s then -- nil value
		return ""
	end
	return string.gsub(s, "'", "''")
end

function run_sql(sql)
	local db = assert(sqlite3.open(GetInfo(66)..clean_file_name(WorldName())..".db"))
	--Note(sql)
	rslt = db:exec(sql)
	--Note(rslt)
	db:close()
end

function load_rooms()
	rooms = {}
sql = [[
		UPDATE rooms SET fillcolour = 0 WHERE fillcolour = ''
	]]
run_sql(sql)
	sql = [[
		SELECT * FROM rooms ORDER BY uid ASC;
	]]
	local db = assert(sqlite3.open(GetInfo(66)..clean_file_name(WorldName())..".db"))
	local cnt = 0
	for row in db:nrows(sql) do
		cnt = cnt + 1
		rooms[row.uid] = {
			name = row.name,
			desc = row.desc,
			area = row.area,
			fillcolour = row.fillcolour,
			fillbrush = row.fillbrush,
			bordercolour = row.bordercolour,
			info = row.info or "",
			notes = row.notes,
			exits = loadstring("return "..row.exits)()
		}
	end
	Note("Loaded ", cnt, " rooms from database.")
    --print("Show Areas: ", show_areas)
    SetVariable("cnt", cnt)
	db:close()

	if tonumber(last_backup) == 0 then
		backup_db()
	end
end

function check_update_room(uid, room)
	if not rooms[uid] or (serialize.save_simple(room) ~= serialize.save_simple(rooms[uid])) then
		add_update_room(uid, room)
	end
end

function add_update_room(uid, room)
	sql = [[
		INSERT OR REPLACE INTO rooms (uid, name, desc, area, fillcolour, fillbrush, bordercolour, info, notes, exits)
		VALUES
		(']]..uid..[[',
		']]..fix_sql(room.name)..[[',
		']]..fix_sql(room.desc)..[[',
		']]..fix_sql(room.area)..[[',
		']]..fix_sql(room.fillcolour)..[[',
		']]..fix_sql(room.fillbrush)..[[',
		']]..fix_sql(room.bordercolour)..[[',
		']]..fix_sql(room.info)..[[',
		']]..fix_sql(room.notes)..[[',
		']]..fix_sql(serialize.save_simple(room.exits))..[[')
	]]
	run_sql(sql)
end

function check_create_db()
	sql = [[
		CREATE TABLE IF NOT EXISTS rooms (
			uid TEXT PRIMARY KEY,
			name TEXT,
			desc TEXT,
			area TEXT,
			fillcolour INTEGER,
			fillbrush INTEGER,
			bordercolour INTEGER,
			info TEXT,
			notes TEXT,
			exits TEXT
		)
	]]
	run_sql(sql)
end

------------------------------------------
-- end of sql additions
------------------------------------------
function room_delete_exit (room, uid, exit)
   local chosen_exit = exit

   if chosen_exit == nil then
      local available =  {}  -- end of available

      -- construct available exits list for display
      for k,v in pairs (room.exits) do
         available [k] = k .. " --> " .. room.exits [k]
      temp_room = k
print ("AvailableK: ", available [k])
print ("Available: ", available )
print ("Temp_Room: ", temp_room)
print ("RoomsK: ", room.exits [k])
    room.exits[k] = nil -- setting table item to nil deletes it
	SendNoEcho("look")
      end -- for

      if next (available) == nil then
         utils.msgbox ("There are no exits from this room.", "No exits!", "ok", "!", 1)
         return
      end -- not known
      local chosen_exit = utils.listbox ("Choose exit to delete", "Exits ...", available )
      if not chosen_exit then
         return
      end
   end
      print("Temp_Room: ", temp_room)
      print("AvailableK: ", available [k])
      
    room.exits[temp_room] = nil -- setting table item to nil deletes it
	run_sql([[DELETE FROM rooms WHERE uid = ']]..room.exits[temp_room]..[[']])
   mapper.mapprint ("Deleted exit '"..chosen_exit.."' from room "..uid.." from database.")
   mapper.mapprint ("Deleted exit '"..chosen_exit.."' from room "..uid.." from database.")

   -- update in-memory table
   add_update_room(uid, rooms[uid])

   mapper.draw (uid)

end -- room_delete_exit

function room_change_exit (room, uid, exit)
   local chosen_exit = exit

   if chosen_exit == nil then
      local available =  {}  -- end of available

      -- construct available exits list for display
      for k,v in pairs (room.exits) do
         available [k] = k .. " --> " .. room.exits [k]
      temp_room = k
      end -- for

      if next (available) == nil then
         utils.msgbox ("There are no exits from this room.", "No exits!", "ok", "!", 1)
         return
      end -- not known

      local chosen_exit = utils.listbox ("Choose exit to change destination of:", "Exits ...", available )
      if not chosen_exit then
         return
      end
--print("Chosen_Exit: ", chosen_exit)
--print ("Temp_Room: ", temp_room)
--print ("exitsK: ", room.exits[chosen_exit])
temp_exit = chosen_exit
   end
--print("Chosen_Exit: ", chosen_exit)
--print ("Temp_Room: ", temp_room)
--print ("exitsK: ", room.exits[chosen_exit])
--print ("TempExit: ", temp_exit)
   exit_destination = utils.inputbox ("Enter destination room identifier (number) for " .. temp_exit, room.name, room.exits[temp_exit])

   if not exit_destination then
      return
   end -- cancelled

   -- look it up
   local dest_room = rooms [exit_destination]

   -- not cached - see if in database
   if not dest_room then
      dest_room = load_room_from_database (exit_destination)
      rooms [exit_destination] = dest_room -- cache for later
   end -- not in cache

   if not dest_room then
      utils.msgbox ("Room " .. exit_destination .. " does not exist.", "Room does not exist!", "ok", "!", 1)
      return
   end -- if still not there

   if exit_destination ~= room.exits[temp_exit] then
      run_sql(string.format ([[
         UPDATE exits SET touid = %s WHERE dir = %s AND fromuid = %s;
         ]],
         fix_sql (exit_destination),
         fix_sql (temp_exit),  -- direction (eg. "n")
         fix_sql (uid)  -- from current room
      ))

      mapper.mapprint ("Modified exit", temp_exit, "from room", uid, "to be to room", exit_destination, "in database.")

      -- update in-memory table
      rooms [uid].exits [temp_exit] = exit_destination
      mapper.draw (current_room)
   else
      mapper.mapprint ("Destination unchanged for exit '"..temp_exit.."'.")
   end

end -- room_change_exit


------------------------------------------
-- backup stuff
------------------------------------------
-- If you want to do manual backups, make an alias with: script="backup_db"
------------------------------------------

function backup_db()
	Note("Creating database backup.")
	local bk_nm = GetInfo(66).."db_backups\\"..clean_file_name(WorldName())..".db."..os.date("%A")
	ffi = require("ffi")
	ffi.cdef[[
		bool CreateDirectoryA(const char *lpPathName, void *lpSecurityAttributes);
		bool CopyFileA(const char* lpExistingFileName, const char * lpNewFileName, bool bFailIfExists);
		unsigned long GetLastError(void);
	]]

	succ = ffi.C.CreateDirectoryA(GetInfo(66).."db_backups\\", nil)
	err_no = ffi.C.GetLastError()
	if err_no and err_no ~= 183 and err_no ~= 127 then
		Note("Error creating directory: ", err_no)
	end

	succ = ffi.C.CopyFileA(GetInfo(66)..clean_file_name(WorldName())..".db", bk_nm, false)

	Note("Backup created: ", bk_nm)
	last_backup = os.time()
end

------------------------------------------
-- end backup stuff
------------------------------------------

-- Special thanks to Fiendish, Endymion, Valour, and Nick Gammon for all of their assistance with the mapper, and the original basis from which its built.

]]>
</script>


</muclient>
