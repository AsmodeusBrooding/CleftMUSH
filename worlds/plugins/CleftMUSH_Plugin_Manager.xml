<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<muclient>
<plugin
   name="CleftMUSH_Update_Manager"
   author="Asmodeus and Pwar"
   id="bad8cd98f00b2c4b21251734"
   language="Lua"
   purpose="Manages updates for CleftMUSH"
   date_written="2020-5-24 01:08:25"
   requires="4.76"
   version="2.03"
   save_state="y"
   >
<description trim="y">
<![CDATA[

]]>
</description>
</plugin>
<aliases>
   <alias
		match="^test$"
		regexp="y"
		enabled="y"
		sequence="100"
		script=""
	>
	</alias>
   <alias
		match="^cmu$"
		regexp="y"
		enabled="y"
		sequence="100"
		script="cmu_main"
	>
   </alias>
   <alias
		match="^cmu help$"
		regexp="y"
		enabled="y"
		sequence="100"
		script="cmu_help"
	>
   </alias>
   <alias
		match="cmu reset$"
		regexp="y"
		enabled="y"
		sequence="100"
		script="cmu_reset"
	>
   </alias>
   <alias
		match="^cmu update ?(?<index>[0-9]+)?$"
		regexp="y"
		enabled="y"
		sequence="100"
		script="cmu_update"
	>
   </alias>
   <alias
		match="^cmu install (?<index>[0-9]+)$"
		regexp="y"
		enabled="y"
		sequence="100"
		script="cmu_install"
	>
	</alias>
   <alias
		match="^cmu reload (?<index>[0-9]+)$"
		regexp="y"
		enabled="y"
		sequence="100"
		script="cmu_reload"
	>
	</alias>
</aliases>
<script>
<![CDATA[
local async = require "async"
local last_update
require "zip"
require "serialize"
require "utility"
dofile(GetPluginInfo(GetPluginID(), 20) .. "cleft_colors.lua")
version = 2.03
local installedPlugins = {}
local lastListHash
local currentPlugin = {}
local pluginList = {}
local updatePlugin = {}
local pListNum = 0
local pluginListUrl = "https://raw.githubusercontent.com/AsmodeusBrooding/CleftUpdater/master/CleftUpdater.xml"
local lastPluginList

function cmu_main(name, line, wc)
  util.print("{x238The {YC{yl{Ye{yf{Yt{RM{rU{RS{rH{D {RA{Yr{Gt{Ci{Bf{Mi{mc{Ri{Ya{Gl {CI{Bn{Mt{me{Rl{Yl{Gi{Cg{Be{Mn{mc{Re {DA{wn{Wd{Dr{wo{Wi{Dd {RS{ru{Rp{re{Rr{D {RCo{rm{Rp{ru{Rt{re{Rr{x238 suddenly snaps into \nexistence and starts furiously compiling new information from the mortal realm.")
   async.HEAD(pluginListUrl, async_head_plist, "HTTPS", 120)
end

function cmu_install(name, line, wc)
   for p = 1, #pluginList do
      if pluginList[p] ~= nil and tonumber(wc.index) == p then
         printmsg("Attempting to install plugin #" .. wc.index .. " (" .. pluginList[p].name .. ")")
         install_plugin(pluginList[p])
         tprint(pluginList[p])
      end
   end
   if #pluginList == 0 then
      printmsg("Error: Unable to read plugin index. Have you typed cmu yet?")
   end
end

function cmu_reset(name, line, wc)
   installedPlugins = {}
   SaveState()
   printmsg("All information about previous updates have been cleared.")
end

function cmu_reload(name, line, wc)
   for p = 1, #pluginList do
      if p == tonumber(wc.index) then
         util.print("\n{R[ {WAttempting to reload plugin #" .. wc.index .. " {R({W" .. pluginList[p].name .. "{R) ]\n")
         for i = 1, #pluginList[p].ids do
            ReloadPlugin(pluginList[p].ids[i])
         end
      end
   end
end

function cmu_update(name, line, wc)
   if wc.index == "" then
      util.print("{R*** {WChecking if an update is available for the {YC{yl{Ye{yf{Yt{RM{rU{RS{rH{W Plugin Manager.. Please wait. {R***\r\n\r\n")
      local url = "https://raw.githubusercontent.com/AsmodeusBrooding/CleftUpdater/master/CleftMUSH_Plugin_Manager.xml"
      async.doAsyncRemoteRequest(url, async_cmu_download_complete, "HTTPS", 120)
   else
      Execute("cmu install " .. wc.index)
   end
end

function cmu_help(name, line, wc)
   print("")
	NoteStyle(2)
	--ColourNote("MediumSeaGreen", "", "CleftMUSH Plugin Manager")
	  util.print("{R================================================================================")
	  util.print("")
      util.print("{W--------------------------------------------------------------------------------")
      util.print("{WPlugin Name  : {YC{yl{Ye{yf{Yt{RM{rU{RS{rH {x238Plugin Manager")
      util.print("{WAuthor       : {x238Asmodeus and Pwar")
      util.print("{WVersion      : {G" .. version)
      util.print("{W--------------------------------------------------------------------------------")
      util.print("")
      util.print("{Y cmu                         {R-->{W Display summary of all plugins")
	  util.print("")
      util.print("{Y cmu install <number>        {R-->{W Downloads, and installs/updates the plugin")
	  util.print("")
      util.print("{Y cmu update                  {R-->{W Checks for an update for cmu itself")
	  util.print("")
      util.print("{Y cmu update <number>         {R-->{W This functions the same as {Y'{Rcmu install{Y'")
	  util.print("")
      util.print("{Y cmu reload <number>         {R-->{W Reloads all xml files related to the plugin")
	  util.print("")
      util.print("{Y cmu reset                   {R-->{W Resets all information about previous updates")
	  util.print("")
      util.print("{Y cmu help                    {R-->{W Displays this help file")
      util.print("")
      util.print("{R================================================================================")

end

function async_head_plist(retval, page, status, headers, full_status, request_url)
   if (lastListHash ~= nil and lastListHash ~= headers["etag"]) or lastPluginList == nil then
      --print("No list hash yet or different one, storing " .. headers["etag"] .. " and beginning download")
      async.doAsyncRemoteRequest(pluginListUrl, async_xml_download_complete, "HTTPS", 120)
   else
      for p = 1, #lastPluginList do
         local thisPlugin = lastPluginList[p]
         thisPlugin.installed = true
         for i = 1, #thisPlugin.ids do
            if not (IsPluginInstalled(thisPlugin.ids[i]) and GetPluginInfo(thisPlugin.ids[i], 17)) then
               thisPlugin.installed = false
               --print("Plugin not installed and enabled!!" .. thisPlugin.ids[i])
            end
         end
         get_plugin_info(thisPlugin)
      end
   end
end

function async_head_plugin(retval, page, status, headers, full_status, request_url)
   local thisPlugin
   pListNum = pListNum + 1
   --if status == 200 then
      if #pluginList == 0  and #lastPluginList > 0 then
         pluginList = lastPluginList
      end
      for i = 1, #pluginList do
         if pluginList[i].download == request_url then
            thisPlugin = pluginList[i]
         end
      end
      if thisPlugin == nil then return end
      thisPlugin.lastModified = headers["etag"] or "Unknown"
	  require("tprint")
	  	--  tprint(headers)
		  LatestTag = headers.etag
		  	--	 print("Hrm: ", headers.etag)
	 -- tprint(headers)
   if pListNum == #pluginList then
      pListNum = 0
      for i = 1, #pluginList do
	--  tprint(pluginList)
         thisPlugin = pluginList[i]
	--	 tprint(thisPlugin)
         thisPlugin.updated = false
		 thisPlugin.lastModified = headers["etag"] or "Unknown"
		-- util.print("{Y[{W"..i.."{Y] {W".. thisPlugin.name)
		 util.print("{R--------------------------------------------------------------------------------\n")
         ColourTell("dimgrey", "", "[" .. i .. "] ", "gold", "", thisPlugin.name .. " ")
         if thisPlugin.installed then
            Hyperlink("cmu reload " .. i, "[Reload Plugin] ", "Reload Plugin #" .. pListNum, "yellow", "black", 0, 1)

            for k, v in pairs(installedPlugins) do
               if thisPlugin.ids[1] == k then
			--   print(thisPlugin.lastModified)
		--	    print(thisPlugin.lastModified)
			  -- print(thisPlugin.lastModified)
                  if thisPlugin.lastModified == LatestTag then
				  			--   tprint(thisPlugin)
                     thisPlugin.updated = true
				     util.print("{G*UP-TO-DATE*")
					 end
                  end
               end

            if not thisPlugin.updated then
               Hyperlink("cmu install " .. i, "[Update Plugin]", "Download and Update Plugin #" .. i, "red", "black", 0, 1)
               print("")
               --if thisPlugin.lastModified ~= "Unknown" then
               --   ColourTell("LightSkyBlue", "", "     Update available since: " .. thisPlugin.lastModified)
               --   print("")
               --end
            end
						util.print("")
            ColourTell("CadetBlue", "", "     " .. textWrap(thisPlugin.description))
            print("\r\n\r\n")
         else
            Hyperlink("cmu install " .. i, "[Install Plugin]", "Download and Install Plugin #" .. pListNum, "DarkOrange", "black", 0, 1)
            --ColourTell("LightSkyBlue", "", thisPlugin.lastModified)
            for k, v in pairs(installedPlugins) do
               --print(k, thisPlugin.ids[1])
               if thisPlugin.ids[1] == k then
                  if thisPlugin.lastModified == v then
                     --print("Same version as installed!")
                  else
                     --print("UPDATE AVAIL!!")
                  end
               end
            end
            print("")
            ColourTell("CadetBlue", "", "     " .. textWrap(thisPlugin.description))
            print("\r\n\r\n")
         end
      end
  --    ColourTell("LightSkyBlue", "", "** Pwar write plugins for fun, and to share with others.\r\n** If you find them useful and would like to donate, I do accept paypals at: ")
  --    Hyperlink("http://paypal.me/hudmond", "http://paypal.me/hudmond", "Click to donate via paypal", "yellowgreen", "", 1)
	  		 		 util.print("{R--------------------------------------------------------------------------------")
      --printmsg("End of plugin list, " .. #pluginList .. " plugins indexed.")
   end
end

function async_cmu_download_complete(retval, page, status, headers, full_status, request_url)
  if status == 200 then
    local version = tonumber(string.match(page, '%s%s+version="([0-9%.]+)"'))
    local installedVer = GetPluginInfo(GetPluginID(), 19)
    if version > installedVer then
      util.print("{WUpdating from version {Y" .. installedVer .. "{W to version {G" .. version)
      local file = io.open(GetPluginInfo(GetPluginID(), 6), "w")
      page = string.gsub(page, "\r", "")
      file:write(page)
      file:close()
      if GetAlphaOption("script_prefix") == "" then SetAlphaOption("script_prefix", "\\\\\\") end
      Execute(GetAlphaOption("script_prefix").."DoAfterSpecial(1, \"ReloadPlugin('"..GetPluginID().."')\", sendto.script)")
    else
      util.print("{WYou are already on version {Y"..version.."{W which is the latest version of the {YC{yl{Ye{yf{Yt{RM{rU{RS{rH {WPlugin Manager{W.")
    end
  else
      printmsg("Plugin update check failed...Error " .. tostring(status))
  end
end

function async_plugin_download_complete(retval, page, status, headers, full_status, request_url)
   local folder
   local xmlFiles = {}
   local xmlFile = {}
   if updatePlugin.installpath == "1" then
      folder = GetInfo(66)
   else
      folder = GetPluginInfo(GetPluginID(), 20)
	  --print(folder)
   end
   --print("FOLDER IS " .. folder)
   if status == 200 then -- download successful
      printmsg("----------------------------------------------")
      printmsg("*** " .. updatePlugin.name .. " download successful.")
      f = assert(io.open (folder .. "temp_update.zip", "wb"))
      f:write(page)
      f:close()
      local zfile, err = zip.open(folder .. "temp_update.zip")
      printmsg("Extracting files from zip:")
      for file in zfile:files() do
         local currFile, err = zfile:open(file.filename)
         local currFileContents = currFile:read("*a") -- read entire contents of current file
		 	--	 print(file.filename)
			--	 print(folder..file.filename)
		---	print(folder)
			FileName = file.filename
			FileName = string.gsub(FileName, "worlds/plugins/", "worlds\\plugins\\")
				print("Folder:Filename" ,folder..file.filename)
				print(FileName)
        NewLoadFile = folder..file.filename
         local hBinaryOutput = io.open(folder..FileName, "wb")
          -- write current file inside zip to a file outside zip
          if(hBinaryOutput)then
	--	  print("YES")
              hBinaryOutput:write(currFileContents)
              hBinaryOutput:close()
          end
         printmsg("(+) " .. file.filename)
         local fileExt = string.sub(file.filename, -4)
         if fileExt == ".xml" then
            xmlFile.filename = file.filename
            --print(xmlFile.filename)
            xmlFile.pluginid = string.match(currFileContents, '%s%s+id="(.-)"')
            table.insert(xmlFiles, xmlFile)
            xmlFile = {}
         end
    --     print(currFile:close())
	--	 print(currFile)
      end
      os.remove(folder .. "temp_update.zip")
	 -- print("REMOVED FOLDER: ", folder)
      printmsg("Update succeeded, loading/reloading plugins.")
      printmsg("----------------------------------------------")
      for i = 1, #updatePlugin.ids do
         --if not IsPluginInstalled(thisPlugin.ids[i]) then
            --LoadPlugin(folder ..
         --end
         --(IsPluginInstalled(thisPlugin.ids[i]) and GetPluginInfo(thisPlugin.ids[i], 17)) then
         --ReloadPlugin(updatePlugin.ids[i])
      end
      for i = 1, #xmlFiles do
         --print(xmlFiles[i].filename, xmlFiles[i].pluginid)
         --local version = tonumber(string.match(page, '%s%s+version="([0-9%.]+)"'))
         if not (IsPluginInstalled(xmlFiles[i].pluginid) and GetPluginInfo(xmlFiles[i].pluginid, 17)) then
            LoadPlugin(NewLoadFile)
			util.print("{x238Plugin {RNOT{x238 loaded, loading now.")
         else
            ReloadPlugin(xmlFiles[i].pluginid)
			util.print("{x238Plugin is already installed....Reloading")
         end
         installedPlugins[xmlFiles[i].pluginid] = headers["etag"]
      end
      SaveState()
   else
      util.print("{x238Plugin download {Rfailed{x238...{RError{x238 " .. tostring(status))
      --printmsg(headers["location"])
   end
   updatePlugin = {}
   xmlFiles = {}
end

function async_xml_download_complete(retval, page, status, headers, full_status, request_url)
   if status == 200 then
      --print(page)
      --print(status)
      lastListHash = headers["etag"]
      SaveState()
      local xml = utils.xmlread(page)
      local num_plugins = #xml.nodes [2].nodes
      --print(num_plugins)
      pluginList = {}
      for p = 1,num_plugins do
         num_plugin_nodes = #xml.nodes [2].nodes [p].nodes
         local thisPlugin = {}
         thisPlugin.ids = {}
         for n = 1, num_plugin_nodes do
            local xmlkey = xml.nodes [2].nodes [p].nodes [n].name
            local xmlval = xml.nodes [2].nodes [p].nodes [n].content
            if xmlkey == "name" then thisPlugin.name = xmlval
            elseif xmlkey == "author" then thisPlugin.author = xmlval
            elseif xmlkey == "description" then thisPlugin.description = xmlval
            elseif xmlkey == "id" then table.insert(thisPlugin.ids, xmlval)
            elseif xmlkey == "download" then thisPlugin.download = xmlval
            elseif xmlkey == "installpath" then thisPlugin.installpath = xmlval
            end
         end
         require "tprint"
         pluginList[p] = thisPlugin
         thisPlugin.installed = true
         for i = 1, #thisPlugin.ids do
            if not (IsPluginInstalled(thisPlugin.ids[i]) and GetPluginInfo(thisPlugin.ids[i], 17)) then
               thisPlugin.installed = false
               --print("Plugin not installed and enabled!!" .. thisPlugin.ids[i])
            end
         end
      end
      lastPluginList = pluginList
      SaveState()
      for p = 1, #pluginList do
         get_plugin_info(pluginList[p])
      end
   else
      printmsg("Downloading plugin list failed...Error " .. tostring(status))
   end
end

function get_plugin_info(plugin)
   local http_mode = string.sub(plugin.download, 1, 5)
   if http_mode == "https" then
      http_mode = string.upper(http_mode)
   else
      http_mode = "HTTP"
   end
   async.HEAD(plugin.download, async_head_plugin, http_mode, 120)
end

function install_plugin(plugin)
   --print("plugin.ids[1]: " .. plugin.ids[1])
   url = plugin.download
   local http_mode = string.sub(url, 1, 5)
   if http_mode == "https" then
      http_mode = string.upper(http_mode)
   else
      http_mode = "HTTP"
   end
   updatePlugin = plugin
   async.doAsyncRemoteRequest(url, async_plugin_download_complete, http_mode, 120)
end

function printmsg(msg)
   ColourNote("cornflowerblue", "", msg)
end


function OnPluginInstall()
   local installedStr = GetVariable("installedPlugins")
   local lastListStr = GetVariable("lastPluginList")
	if installedStr ~= nil then
		installedPlugins = load( "return "..installedStr)( )
	end
   if lastListStr ~= nil then
		lastPluginList = load( "return "..lastListStr)( )
	end
   lastListHash = GetVariable("lastListHash")
      util.print("{W--------------------------------------------------------------------------------")
      util.print("{WPlugin Name  : {YC{yl{Ye{yf{Yt{RM{rU{RS{rH {x238Plugin Manager has been loaded!")
      util.print("{WAuthor       : {x238Asmodeus and Pwar")
      util.print("{WVersion      : {G" .. version)
      util.print("{W--------------------------------------------------------------------------------")
      util.print("")
      util.print("{x238Type {Ycmu{x238 or {Ycmu help{x238 to find new plugins or update existing ones.")
      util.print("")
      util.print("{W--------------------------------------------------------------------------------")
	  print("")
end

function OnPluginSaveState()
		-- this will run when SaveState() is called or if mush is closing etc
   if installedPlugins ~= nil then
      SetVariable("installedPlugins", serialize.save_simple(installedPlugins))
   end
   if lastListHash ~= nil then
      SetVariable("lastListHash", lastListHash)
   end
   if lastPluginList ~= nil then
      SetVariable("lastPluginList", serialize.save_simple(lastPluginList))
   end
end

-- Utils --
function md5sum(filename)
	if filename then
		f = io.open (filename, "rb")
		if f then
			print ("File: " .. filename .. " - md5sum =", utils.tohex (utils.md5 (f:read ("*a"))))
			f:close()
		end
	end
end

function textWrap( str, limit, indent, indentFirst )

    limit = limit or 72
    indent = indent or ""
    indentFirst = indentFirst or indent

    local here = 1 - #indentFirst
    return indentFirst .. str:gsub( "(%s+)()(%S+)()",
        function( sp, st, word, fi )
            if fi - here > limit then
                here = st - #indent
                return "\n" .. indent .. word
            end
        end
    )
end

]]>
</script>
</muclient>
