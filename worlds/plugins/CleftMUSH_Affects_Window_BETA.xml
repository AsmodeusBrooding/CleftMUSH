<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Sunday, July 03 2019 .06-pre -->

<!-- Plugin "CleftMUSH_Group_Window" generated by Plugin Wizard -->
<!-- Code frome Asmodeus, Nick Gammon -->
<muclient>
<plugin
name="CleftMUSH_Affects_Window"
author="Glade, Asmodeus"
id="353de94ba6c43260d839e256"
save_state="y"
language="Lua"
purpose="Affects Window"
date_written="2019-07-03 12:04:56"
requires="5.00"
version="0.65"
>

</plugin>

<!--  Timers  -->

<timers>
  <timer
      script="PlayAllMovieFrames"
      enabled="y"
      second="0.1"
      active_closed="y"
      >

  </timer>
</timers>


<!--  Aliases  -->

<aliases>
  <alias
      regexp="y"
      match="^affects window$"
      enabled="y"
      sequence="100"
      script="toggle"
      >
  </alias>
  <alias
      regexp="y"
      match="^affects window debug$"
      enabled="y"
      sequence="100"
      script="ToggleDebug"
      >
  </alias>
</aliases>

<!--  Triggers  -->

<triggers>
  <trigger
   enabled="y"
   lines_to_match="2"
   match="\AYou are affected by:\n---------------------------------------------------------\Z"
   multi_line="y"
   name="aff_start"
   script="AffectsListStart"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  </trigger>
  <trigger
      enabled="y"
      match="^You are (hungry|thirsty)\.$"
      regexp="y"
      send_to="12"
      keep_evaluating="n"
      sequence="50"
      name="AddHungerThirst"
      script="AddAffect"
      >
  </trigger>
  <trigger
      enabled="y"
      match="\|.+\| \[(HUNGER|THIRST)\].*"
      regexp="y"
      send_to="12"
      sequence="100"
      name="AddHungerThirstScore"
      script="AddAffect"
      >
  </trigger>
  <trigger
      enabled="y"
      match="^(((You are )(no longer )?)|(Your ))(?<affect>full|hungry|thirst)( is quenched)?\.$"
      regexp="y"
      send_to="12"
      sequence="100"
      script="RemoveAffect"
      >
  </trigger>
  <trigger
      enabled="y"
      match="Your (magical )?(?<affect>charge) (dissipates|wears off)."
      regexp="y"
      send_to="12"
      sequence="100"
      script="RemoveAffect"
      >
  </trigger>
</triggers>

<!--  Script  -->

<script>
  <![CDATA[
	require "movewindow"
	require "mw"
	require "mw_theme_base"

	-- Miniwindow State
	local winid = "win_"..GetPluginID()
	local bg_color = "#000000"
	local title_bg_color = "#303030"
	local border_color = "#303030"
	local title_color = "#FFFFFF" -- window title color
	local last_refresh = 1 -- last window refresh
	local pos_x = GetVariable("pos_x") or 100
	local pos_y = GetVariable("pos_y") or 100
	local font_size = 8
	local font_name = "Lucida Console"
	local window_visible = true -- always start out with visible window
	local title = "Affects Window"
	local win_height = tonumber(GetVariable("win_height")) or 400
	local win_width = tonumber(GetVariable("win_width")) or 440
	local grip_resize = 10 -- resize grip size

	-- Global Vars
	infos = {}
	affects = {}
	-- In game name to filename map
	affect_icons = {
	   ["invisibility"] = "invis",
	   ["charge"] = "charge",
	   ["nayrus love"] = "nayrus_love",
	   ["protect"] = "protect",
	   ["charge"] = "charge",
	   ["power surge"] = "power_surge",
	   ["attack up"] = "attackup",
	   ["hungry"] = "hungry",
	   ["thirsty"] = "thirsty"}

	path_prefix = "worlds\\plugins\\images\\affects\\"
	debug = GetVariable("debug") or false
	pulse_length = 4

	function DebugNote(message)
	   if(debug) then
	      Note(message)
	   end
	end

	function toggle()
	   window_visible = not window_visible
	   if not window_visible then -- remove window
	      WindowDelete(winid)
	   else
	      window(true)
	   end
	end

	function ToggleDebug()
	   debug = not debug
	   Note("Debug is now " .. tostring(debug))
	   SaveState()
	end

	function AffectsListStart(name, line, wildcards)
	   DebugNote("got start of Affects")
	   AddTriggerEx("GRAB_SPELLS_TIME", "^(.*?) +(?:modifies .*? -?\\d+ )?for (\\d+) pulses.*?$", "", trigger_flag.Enabled + trigger_flag.RegularExpression, custom_colour.NoChange, 0, "", "AddAffectTimed", 0, 100)
	   AddTriggerEx("GRAB_SPELLS_INDEFINITELY", "^(.*?) +(indefinitely).*$", "", trigger_flag.Enabled + trigger_flag.RegularExpression, custom_colour.NoChange, 0, "", "AddAffect", 0, 100)
	   AddTriggerEx("AFF_END", "---------------------------------------------------------", "", trigger_flag.Enabled + trigger_flag.OneShot, custom_colour.NoChange, 0, "", "AffectsListEnd", 0, 100)
	end -- AffectsListStart

	function AffectsListEnd(name, line, wildcards)
	   DebugNote("AffectsListEnd")
	   DeleteTrigger("GRAB_SPELLS_TIME")
	   DeleteTrigger("GRAB_SPELLS_INDEFINITELY")
	end -- AffectsListEnd

	-- --------------------------------------------------------------------
	-- AddAffect (name, line, wildcards)
	-- wildcards[1] must be in affect_icons table, otherwise prompt user for icons
	-- --------------------------------------------------------------------
	function AddAffectTimed(name, line, wildcards)
	   DebugNote("AddAffectTimed")
	   if(wildcards[1] ~= nil and wildcards[2] ~= nil) then
	      DebugNote("Spell: " .. wildcards[1])
	      DebugNote("Duration: " .. wildcards[2])
	      spell = wildcards[1]:lower()
	      duration = tonumber(wildcards[2])
	      local k, v = FindAffectInInfos(spell)
	      if(k == -1 and duration > 0 and affect_icons[spell] ~= nil) then
		 DebugNote("Adding New Timed Affect")
		 PlaceNewGIF(path_prefix .. affect_icons[spell] .. "_%03i.png")
		 hours, minutes, seconds = GetTimerTime(duration)
		 DebugNote(string.format("%02d:%02d:%02d", hours, minutes, seconds))
		 spell = string.gsub(spell, " ", "_")
		 DebugNote("timer retval: " .. AddTimer(spell, hours, minutes, seconds, "", timer_flag.Enabled + timer_flag.OneShot, "RemoveAffectTimed"))
		 DebugNote("timer: " .. GetTimer(spell))
	      end -- if
	   end -- if
	end -- AddEffectTimed

	function GetTimerTime(pulses)
	   seconds = pulses * pulse_length
	   local hours = math.floor((seconds % 86400)/3600)
	   local minutes = math.floor((seconds % 3600)/60)
	   local seconds = math.floor(seconds % 60)
	   return hours, minutes, seconds
	end -- GetTimerTime

	-- --------------------------------------------------------------------
	-- AddAffect (name, line, wildcards)
	-- wildcards[1] must be in affect_icons table, otherwise prompt user for icons
	-- --------------------------------------------------------------------
	function AddAffect(name, line, wildcards)
	   DebugNote("AddAffect")
	   DebugNote(wildcards[1])
	   if(wildcards[1] ~= nil) then
	      wildcards[1] = FixWildcardsForHungerThirst(wildcards[1])
	      local k, v = FindAffectInInfos(wildcards[1])
	      DebugNote(wildcards[1])
	      if(k == -1) then
		 if(affect_icons[wildcards[1]] ~= nil) then
		    PlaceNewGIF(path_prefix .. affect_icons[wildcards[1]] .. "_%03i.png")
		 end
	      end -- if
	   end -- if
	end -- AddEffect

	function FixWildcardsForHungerThirst(match)
	      if (match == "HUNGER" or match == "full") then
		 match = "hungry"
	      elseif (match:lower() == "thirst") then
		 match = "thirsty"
	      end -- if
	      return match
	end

	-- --------------------------------------------------------------------
	-- RemoveAffectTimed (name, line, wildcards)
	-- wildcards[1] must be an active effect
	-- --------------------------------------------------------------------
	function RemoveAffectTimed(name)
	   DebugNote("RemoveAffectTimed")
	   name = string.gsub(name, "_", " ")
	   DebugNote(name)
	   if(name ~= nil) then
	      local k, v = FindAffectInInfos(name)
	      DebugNote("k:" .. tostring(k))
	      if (k >= 0) then
		 DebugNote("Removing " .. tostring(k))
		 table.remove(infos, k)
		 window(true) -- Redraw
	      end -- if
	   end -- if
	end -- RemoveAffect

	-- --------------------------------------------------------------------
	-- RemoveAffect (name, line, wildcards)
	-- wildcards[1] must be an active effect
	-- --------------------------------------------------------------------
	function RemoveAffect(name, line, wildcards)
	   DebugNote("RemoveAffect")
	   if(wildcards["affect"] ~= nil) then
	      affect = wildcards["affect"]
	      affect = FixWildcardsForHungerThirst(affect)
	      affect = affect:lower()
	      DebugNote(affect)
	      local k, v = FindAffectInInfos(affect)
	      DebugNote("k:" .. tostring(k))
	      if (k >= 0) then
		 DebugNote("Removing " .. tostring(k))
		 table.remove(infos, k)
		 affect = string.gsub(affect, " ", "_")
		 Note(affect)
		 Note(DeleteTimer(affect))
		 window(true) -- Redraw
	      end
	   end
	end -- RemoveAffect

	function FindAffectInInfos(name)
	   for k, v in pairs(infos) do
	      if (affect_icons[name] ~= nil and string.match(v.filename, affect_icons[name]) ~= nil) then
		 return k, v
	      end
	   end
	   return -1, -1
	end -- FindAffectInInfos

	function GetNumFrames(filename)
	   return GetNumFramesHelper(filename, 0)
	end -- GetNumFrames

	function GetNumFramesHelper(filename, i)
	   old_filename = filename
	   filename = string.format (filename, i + 1)
	   DebugNote("filename_numframehelp = " .. filename)
	   local f = io.open(filename, "r")
	   if f ~= nil and i < 1000 then
	      io.close(f)
	      filename = old_filename
	      return GetNumFramesHelper(filename, i + 1)
	   else
	      DebugNote("f no exists::i=" .. tostring(i))
	      return i
	   end
	end -- GetNumFrames

	-- --------------------------------------------------------------------
	-- PlayGif (info)
	--  info.filename (eg. "/frames/my_Gif_%03i.png" )
	--  info.frames   (eg. 10, if the Gif consists of 10 files)
	--  info.x   - X position on screen
	--  info.y   - Y position on screen

	--  Suggested conversion:
	--    ffmpeg -ss "00:30" -i INPUTFILE.mp4 -t 1     -r 10 -s 720x404 frames/my_Gif_%03i.png
	--                ^^^^          ^^^       ^^^^     ^^^^^    ^^^^^^^    ^^^^^^^^^^
	--           Start time      input file  how long   FPS       size      output files
	-- --------------------------------------------------------------------

	function PlayMovie (info)
	   movieInfo = info

	   if not info then
	      return
	   end -- if

	   assert (type (movieInfo) == "table",
		   "Argument to PlayMovie should be a table")

	   -- see if already in table
	   if infos [info.filename] then
	      --return
	   end -- if already there

	   local gotErrors = false

	   -- load each movie frame into memory, if not already done
	   for i = 1, movieInfo.frames do
	      local filename = string.format (movieInfo.filename, i)
	      if not WindowImageInfo(winid, filename, 2) then
		 local result = WindowLoadImage(winid, filename, filename)
		 if result ~= error_code.eOK then
		    ColourNote ("Red", "", "Could not open move frame file:")
		    ColourNote ("Red", "", "   -> " .. filename)
		    ColourNote ("Red", "", "   Reason: " .. error_desc [result])
		    gotErrors = true
		 end -- if
	      end -- if
	   end -- for each frame

	   -- if couldn't do it, discard the movie info
	   if gotErrors then
	      movieInfo = nil
	      return
	   end -- if

	   -- otherwise, start at frame 1
	   movieInfo.currentFrame = 1

	   -- put into table of infos
	   table.insert(infos, movieInfo)
	end -- PlayMovie

	-- --------------------------------------------------------------------
	-- PlayMovieFrame - show current frame, advance count
	-- --------------------------------------------------------------------
	function PlayMovieFrame (movieInfo)
	   -- timing stuff
	   timeTaken = timeTaken or 0
	   frameCount = frameCount or 0

	   local startTime = utils.timer ()
	   local filename = string.format (movieInfo.filename, movieInfo.currentFrame)
	   if WindowDrawImage (winid, filename, movieInfo.x, movieInfo.y, 0, 0,
			       miniwin.image_copy) ~= error_code.eOK then
	      ColourNote ("Orange", "", "Could not draw image: " .. filename)
	   end -- if
	   Redraw () -- force screen update

	   -- next frame
	   movieInfo.currentFrame = movieInfo.currentFrame + 1
	   -- wrap
	   if movieInfo.currentFrame > movieInfo.frames then
	      movieInfo.currentFrame = 1
	   end -- if

	   -- add up how long we took doing this
	   timeTaken = timeTaken + utils.timer () - startTime
	   -- and how many times
	   frameCount = frameCount + 1
	end -- PlayMovieFrame


	-- --------------------------------------------------------------------
	-- PlayAllMovieFrames - called by a timer every 1/10 second - calls
	--                      PlayMovieFrame for each movie in the table
	-- --------------------------------------------------------------------
	function PlayAllMovieFrames (timerName)

	   for k, v in pairs (infos) do
	      PlayMovieFrame (v)
	   end -- for

	end -- PlayAllMovieFrames

	function TableLength(T)
	   local count = 0
	   for _ in pairs(T) do count = count + 1 end
	   return count
	end


	-- 16x16 at top, 32x32 below
	-- Offsets due to window border
	x_off = 2
	y_off = 18
	gif_size = 32
	-- --------------------------------------------------------------------
	-- PlaceNewGif (filename, frames)
	--  filename (eg. "bread" ), expected to be in worlds/plugins/images/frames/filename_%03i.png
	-- --------------------------------------------------------------------
	function PlaceNewGIF(filename, frames)
	   DebugNote("PlaceNewGIF")
	   DebugNote("filename: " .. filename)
	   local rows = math.floor(win_height / gif_size)
	   local cols = math.floor(win_width / gif_size)
	   local frames = GetNumFrames(filename)
	   DebugNote("frames: " .. tostring(frames))
	   DebugNote("win_width " .. win_width)
	   DebugNote("win_height " .. win_height)
	   DebugNote("row " .. rows)
	   DebugNote("col " .. cols)
	   if (frames ~= 0) then
	      num_gifs = #infos
	      movieInfo = info

	      -- Find position

	      x,y = FindNextPos(32)
	      PlayMovie {
		 filename = filename,
		 frames = frames,
		 x = x,
		 y = y,}
	   elseif(not warned_about_missing_files) then
	      warned_about_missing_files = true
	      ColourNote ("Red", "", "Could not find any frames matching " .. filename)
	   end
	end

	function FindNextPos(size)
	   rows = math.floor(win_height / gif_size)
	   cols = math.floor(win_width / gif_size)
	   cur_col = math.floor((#infos) % cols)
	   cur_row = math.floor((#infos)/ cols) >= 0 and math.floor((#infos)/ cols) or 0
	   x = x_off + cur_col*size
	   y = y_off + cur_row*size
	   --DebugNote("#infos " .. #infos)
	   --DebugNote("num_row " .. num_row)
	   --DebugNote("cur_row " .. cur_row)
	   --DebugNote("cur_row_test " .. cur_row_test)
	   --DebugNote("num_col " .. num_col)
	   --DebugNote("cur_col " .. cur_col)
	   --DebugNote("cols " .. cols)
	   --DebugNote("rows " .. rows)
	   return x, y
	end

	function window(redraw)
	   DebugNote("window(" .. tostring(redraw) .. ")")
	   if not window_visible then
	      return
	   end

	   if redraw then
	      WindowDelete("winid")
	      WindowCreate(winid, pos_x, pos_y, win_width, win_height, 0, 0, ColourNameToRGB(bg_color))
	      WindowPosition(winid, pos_x, pos_y, 0, 2)
	      WindowSetZOrder(winid, 201)
	      WindowFont(winid, "f1", font_name, font_size, false, false, false, false)
	      WindowFont(winid, "b1", font_name, font_size, true, false, false, false)
	      WindowFont(winid, "s1", font_name, font_size - 1, false, false, false, false)
	      movewindow.install(winid, 6, 2, true, nil, {mouseup=MouseUp, mousedown=MouseDown, dragmove=LeftClickOnly, dragrelease=LeftClickOnly})
	      -- register with the z-order monitor
	      CallPlugin("462b665ecb569efbf261422f", "registerMiniwindow", winid)
	      movewindow.add_drag_handler (winid, 0, 0, 0, win_height)
	      WindowAddHotspot(winid, "resize", win_width - grip_resize, win_height - grip_resize, win_width, win_height, "MouseOver", "CancelMouseOver", "MouseDown", "", "MouseUp", "", 6, 0)
	      WindowDragHandler(winid, "resize", "ResizeMoveCallback", "ResizeReleaseCallback", 0)
	   else
	      WindowResize(winid, win_width, win_height, ColourNameToRGB(bg_color))
	      WindowMoveHotspot(winid, "resize", win_width - grip_resize, win_height - grip_resize, win_width, win_height)
	   end
	   -- Redraw icons
	   if (#infos >= 1) then
	      tmp_infos = infos
	      infos = {}
	      warned = false
	      for i, v in ipairs(tmp_infos) do
		 x, y = FindNextPos(32)
		 v.x = x
		 v.y = y
		 if(not warned and (x > win_width or y > win_height)) then
		    warned = true
		    Note("Your Affects window is too small to show all the icons, make it bigger!")
		 end
		 table.insert(infos, v)
	      end
	   end
	   WindowShow(winid, true)
	   show_window()
	end

	function show_window()
	   WindowRectOp(winid, 2, 2, 1, -2, -2, ColourNameToRGB(bg_color)) -- blank canvas
	   --WindowRectOp(winid, 2, 0, 0, 0, 22, ColourNameToRGB(title_bg_color)) -- title background
	   --WindowRectOp(winid, 1, 0, 0, 0, 0, ColourNameToRGB(border_color)) -- border
	   --Theme.Draw3DRect(winid, 0, 0, 0, 0, depressed) -- themed window

	   title = "Affects Window" -- default title

	   Theme.DrawTitleBar(winid, "f1", title, "center") -- them window title (has to be drawn before border) This is the title bar that says the leader name
	   Theme.DrawBorder(winid) -- theme window border

	   left, top = 7, 17 -- bar location
	   across = 0
	   rows = 0
	   Theme.AddResizeTag(winid, 2, nil, nil, "MouseDown", "ResizeMoveCallback", "ResizeReleaseCallback") -- resize grip
	end

	function ResizeMoveCallback()
	   --DebugNote("ResizeMoveCallback")
	   local x_offset, y_offset = start_x - WindowInfo(winid, 17), start_y - WindowInfo(winid, 18)
	   start_x, start_y = WindowInfo(winid, 17), WindowInfo(winid, 18)
	   win_width = win_width - x_offset
	   win_height = win_height - y_offset
	   if os.clock() - last_refresh >= .05 then
	      --DebugNote("redraw")
	      last_refresh = os.clock()
	      window(false)
	   end
	end

	function ResizeReleaseCallback()
	   --DebugNote("ResizeReleaseCallback")
	   window(true)
	   SaveState()
	end

	function MouseDown(flags, id)
	   --DebugNote("MouseDown")
	   if id == "resize" then
	      start_x, start_y = WindowInfo(winid, 17), WindowInfo(winid, 18)
	   end
	end

	function MouseUp(flags, id, win)
	   --DebugNote("MouseUp")
	   if bit.band(flags, 0x20) ~= 0 then -- right click
	      right_click_menu()
	   end
	   pos_x, pos_y = WindowInfo(winid, 10), WindowInfo(winid, 11)
	   SaveState()
	end

	function right_click_menu()
	   local x, y = WindowInfo(winid, 14), WindowInfo(winid, 15)

	   local str = "!"

	   str = str.."Bring to Front"

	   str = str.."|-|Send to Back"

	   opt = WindowMenu(winid, x, y, str)

	   if opt == "" then
	      return
	   end

	   opt = tonumber(opt)

	   if opt == 1 then -- Bring to Front
	      CallPlugin("462b665ecb569efbf261422f","boostMe", winid)
	      --  print("Bring to Front")
	      SaveState()
	   elseif opt == 2 then -- Send to back
	      CallPlugin("462b665ecb569efbf261422f","dropMe", winid)
	      --  print("Sent to Back")
	      SaveState()
	   end
	   window(true)
	end

	function CancelMouseOver(flags, id)
	   --DebugNote("CancelMouseOver")
	   -- nothing
	end

	function CancelMouseDown(flags, id)
	   --DebugNote("CancelMouseDown")
	   -- nothing
	end

	function SaveState()
	   SetVariable("pos_x", pos_x)
	   SetVariable("pos_y", pos_y)
	   SetVariable("win_width", win_width)
	   SetVariable("win_height", win_height)
	   SetVariable("debug", tostring(debug))
	end

	function OnPluginEnable()
	   --DebugNote("enabled")
	   window(true)
	end

	function OnPluginDisable()
	   WindowDelete(winid)
	end

	function OnPluginClose()
	   WindowDelete(winid)
	end

	function OnPluginSaveState()
	   SaveState()
	end

	function OnPluginWorldSave()
	   SaveState()
	end

	function OnPluginDisable()
	   SaveState()
	end

	function OnPluginDisconnect()
	   SaveState()
	end

	-- For saving state when reloading w/ bast's plugins plugin
	function OnPluginListChanged()
	   SaveState()
	end

	window(true)
    ]]>
</script>

</muclient>
